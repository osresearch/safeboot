{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"safeboot: Booting Linux Safely Goals safeboot has five goals to improve the safety of booting Linux on normal laptops: Booting only code that is authorized by the system owner (by installing a hardware protected platform key for the kernel and initrd) Streamlining the encrypted disk boot process (by storing keys in the TPM, and only unsealing them if the firmware and configuration is unmodified) Reducing the attack surface (by enabling Linux kernel features to enable hardware protection features and to de-privilege the root account) Protecting the runtime system integrity (by optionally booting from a read-only root with dmverity and signed root hash) Proving to remote systems that the local machine is safe (using a remote attestation protocol built with the TPM2) The threat model page has more detail about the firmware, kernel, and runtime changes, as well as how they help achieve these goals and the threats that they help protect against. Why safeboot? The slightly more secure Heads firmware is a better choice for user freedom since it replaces the proprietary firmware with open source. However, Heads and LinuxBoot only support a limited number of mainboards and systems, while safeboot's objective is to work with existing commodity hardware and UEFI SecureBoot mechanisms, as well as relatively stock Linux distributions. The problem is that configuring all of the pieces for UEFI Secure Boot, generating keys in hardware tokens, signing kernels, and integrating LUKS disk encryption with the TPM is very complex. There are numerous guides that walk through individual pieces of this process, but most of them are very fine-grained and require far too many steps to complete. Likewise the tpm2-tools package has all of the low-level API calls for interacting with the TPM and the various endorsement and attestation keys, but no easy way to generate signed quotes and perform remote attestation. Like they say in the informercials: \" there has to be a better way! \" End users and administrators need a tool that wraps up all of the complexity into the few operations that they need from day to day: signing new kernels, decrypting their disks at boot, protecting the system from runtime attackers, attesting to the integrity of their systems, etc. safeboot and tpm2-attest are (early versions of) those tools! Links Installation Instructions for configuring safeboot Threat Model that safeboot is trying to protect against Frequently Asked Questions about safeboot TPM2 Remote Attestation protocol for accessing network resources Chain of Trust for booting a modern x86 CPU Source code safeboot subcommands tpm2-attest subcommands attest-enroll Status","title":"Overview"},{"location":"#safeboot-booting-linux-safely","text":"","title":"safeboot: Booting Linux Safely"},{"location":"#goals","text":"safeboot has five goals to improve the safety of booting Linux on normal laptops: Booting only code that is authorized by the system owner (by installing a hardware protected platform key for the kernel and initrd) Streamlining the encrypted disk boot process (by storing keys in the TPM, and only unsealing them if the firmware and configuration is unmodified) Reducing the attack surface (by enabling Linux kernel features to enable hardware protection features and to de-privilege the root account) Protecting the runtime system integrity (by optionally booting from a read-only root with dmverity and signed root hash) Proving to remote systems that the local machine is safe (using a remote attestation protocol built with the TPM2) The threat model page has more detail about the firmware, kernel, and runtime changes, as well as how they help achieve these goals and the threats that they help protect against.","title":"Goals"},{"location":"#why-safeboot","text":"The slightly more secure Heads firmware is a better choice for user freedom since it replaces the proprietary firmware with open source. However, Heads and LinuxBoot only support a limited number of mainboards and systems, while safeboot's objective is to work with existing commodity hardware and UEFI SecureBoot mechanisms, as well as relatively stock Linux distributions. The problem is that configuring all of the pieces for UEFI Secure Boot, generating keys in hardware tokens, signing kernels, and integrating LUKS disk encryption with the TPM is very complex. There are numerous guides that walk through individual pieces of this process, but most of them are very fine-grained and require far too many steps to complete. Likewise the tpm2-tools package has all of the low-level API calls for interacting with the TPM and the various endorsement and attestation keys, but no easy way to generate signed quotes and perform remote attestation. Like they say in the informercials: \" there has to be a better way! \" End users and administrators need a tool that wraps up all of the complexity into the few operations that they need from day to day: signing new kernels, decrypting their disks at boot, protecting the system from runtime attackers, attesting to the integrity of their systems, etc. safeboot and tpm2-attest are (early versions of) those tools!","title":"Why safeboot?"},{"location":"#links","text":"Installation Instructions for configuring safeboot Threat Model that safeboot is trying to protect against Frequently Asked Questions about safeboot TPM2 Remote Attestation protocol for accessing network resources Chain of Trust for booting a modern x86 CPU Source code safeboot subcommands tpm2-attest subcommands attest-enroll","title":"Links"},{"location":"#status","text":"","title":"Status"},{"location":"attest-enroll/","text":"This script, sbin/attest-enroll implements enrollment of a device into the attestation system using the device's TPM's Endorsement Key's public key ( EKpub ). It takes as arguments an EKpub or the EKpub 's public key in PEM form, and a desired hostname , and it creates the enrollment state for that tuple. Enrollment state consists of: the EKpub the hostname any configured secrets and metadata for that device, with secrets encrypted to the EKpub Secrets are encrypted to the EKpub using sbin/tpm2-send . More on this below . The enrollment database is file based. The directory structure looks like: $DBDIR/??/... # enrollment state for enrolled hosts $DBDIR/${ekhash:0:2}/${ekhash}/ # <- enrollment state for SHA-256(EKpub) $DBDIR/${ekhash:0:2}/${ekhash}/ # <- enrollment state for SHA-256(EKpub) $DBDIR/hostname2ekpub/ # <- index by hostname $DBDIR/hostname2ekpub/${hostname} # <- file containing ${hostname}'s SHA-256(EKpub) $DBDIR/hostname2ekpub/... Configuration is via bash scripts sourced by sbin/attest-enroll : /etc/safeboot-enroll/conf # Principal config file (optional) $DBDIR/attest-enroll.conf # Additional config file (optional) Configuration parameters can also be given on the command-line. See the sbin/attest-enroll usage message for more details. Escrow of Enrolled Secrets If an ESCROW_PUBS_DIR is configured, then every secret subsequently encrypted to any TPM is also encrypted to the defined escrow authorities' public keys: $ESCROW_PUBS_DIR/ # <- EKpubs/PEM of escrow agents here (optional) $ESCROW_PUBS_DIR/someEscrowName.pub # EKpub $ESCROW_PUBS_DIR/otherEscrowName.pem # Public key in PEM form Enrollment State Generation Enrollment state is generated by configured genprog s. Two built-in genprogs are: genhostname -- creates the metadata file recording the hostname, genrootfskey -- creates a 64-byte secret key for root filesystem / volume encryption. Other, external genprog s can be added and configured. The following external genprog s are included: gencert -- creates a private key and a certificate for its public key naming the hostname , genkeytab -- creates a \"keytab\" with the keys for the hostname 's host service Kerberos principal. Sites can provide additional genprog s to generate a large variety of credentials and metadata: PKIX certificates for IPsec, TLS, and/or other purposes OpenSSH host keys and possibly OpenSSH host key certificates Service access tokens Encryption Encryption is implemented by sbin/tpm2-send . Decryption is implemented by sbin/tpm2-recv . Two methods are possible for encryption to a target TPM's EKpub : the \"WK\" method (our name for it) the \"TK\" method (our name for it) Both methods support setting a policy on the ciphertext such that any application using the target's TPM to decrypt it must first execute and satisfy that policy. The \"WK\" method uses TPM2_MakeCredential() via tpm2-tools' tpm2 makecredential command, using the none TCTI (i.e., implemented in software). The target's EKpub is used as the handle input parameter to TPM2_MakeCredential() . A well-known key ( WK ), and the desired policy (if any) are used to compute the cryptographic name of the \"activation object\" ( objectName ) input parameter to TPM2_MakeCredential() . Decryption consists of calling TPM2_ActivateCredential() with the handle to the WK as the activationHandle input parameter, and the EK as the keyHandle input parameter of TPM2_ActivateCredential() . If a policy is desired then the adminWithPolicy attribute will be set on the WKname , which will cause TPM2_ActivateCredential() to require that the policy be satisfied. The \"TK\" method uses TPM2_Duplicate() via tpm2-tools' tpm2 duplicate command using the none TCTI (i.e., implemented in software. An RSA keypair is generated and its private key is exported to the target TPM using TPM2_Duplicate() -- we call this the \"transport key\", the TK . The small secret will then be encrypted to the TK 's public key ( TKpub ). Decryption works by importing the exported TK and then using TPM2_RSA_Decrypt() to decrypt the small secret encrypted to the TKpub . Encryption of Larger Secrets In all cases, regardless of a secret's size, we use sbin/tpm2-send to encrypt an ephemeral, random AES-256 key to the target's TPM, then we encrypt the actual secret in that AES key in confounded AES-256-CBC-HMAC-SHA-256 cipher mode. The final ciphertext consists of those two ciphertexts: the one generated by sbin/tpm2-send and the one generated by AES encryption. Encryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: prepending a full cipher block of random bits (the \"confounder\") to the plaintext, encrypting the plaintext in AES-256 in cipher block chaining (CBC) mode with padding and zero IV, appending the HMAC of the resulting ciphertext using SHA-256 as the hash function for HMAC. Decryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: computing the HMAC-SHA-256 of the ciphertext excluding the MAC, checking that the HMAC of the ciphertext matches the HMAC in the ciphertext, decryption of the ciphertext using AES-256 in CBC with zero IV, removing the first full cipher block of the plaintext (the \"confounder\"), removing the padding. The confounder serves mainly to function as a sort of explicit random IV while allowing us to use a zero IV in the openssl enc command invocations. Since all of this is implemented in bash with openssl , and OpenSSL does not provide a decent authenticated encryption mode for AES, we script the confounded AES-256-CBC-HMAC-SHA-256 cipher mode, which turns out to be simple and elegant in bash. With OpenSSL 3.0 we could use ciphertext stealing mode (CTS) instead of CBC, and then we'd be using exactly the same more as Kerberos uses (confounded CTS with HMAC). The CTS cipher mode is a variant of CBC mode that avoids the need for padding, in exchange for which advantage CTS requires plaintexts to be at least one full cipher block (16 bytes) long, thus CTS is always used with a confounder, and the confounder functions as an explicit IV that allows the external IV to be zero.","title":"attest-enroll: enrolling a device for TPM2 remote attestation"},{"location":"attest-enroll/#escrow-of-enrolled-secrets","text":"If an ESCROW_PUBS_DIR is configured, then every secret subsequently encrypted to any TPM is also encrypted to the defined escrow authorities' public keys: $ESCROW_PUBS_DIR/ # <- EKpubs/PEM of escrow agents here (optional) $ESCROW_PUBS_DIR/someEscrowName.pub # EKpub $ESCROW_PUBS_DIR/otherEscrowName.pem # Public key in PEM form","title":"Escrow of Enrolled Secrets"},{"location":"attest-enroll/#enrollment-state-generation","text":"Enrollment state is generated by configured genprog s. Two built-in genprogs are: genhostname -- creates the metadata file recording the hostname, genrootfskey -- creates a 64-byte secret key for root filesystem / volume encryption. Other, external genprog s can be added and configured. The following external genprog s are included: gencert -- creates a private key and a certificate for its public key naming the hostname , genkeytab -- creates a \"keytab\" with the keys for the hostname 's host service Kerberos principal. Sites can provide additional genprog s to generate a large variety of credentials and metadata: PKIX certificates for IPsec, TLS, and/or other purposes OpenSSH host keys and possibly OpenSSH host key certificates Service access tokens","title":"Enrollment State Generation"},{"location":"attest-enroll/#encryption","text":"Encryption is implemented by sbin/tpm2-send . Decryption is implemented by sbin/tpm2-recv . Two methods are possible for encryption to a target TPM's EKpub : the \"WK\" method (our name for it) the \"TK\" method (our name for it) Both methods support setting a policy on the ciphertext such that any application using the target's TPM to decrypt it must first execute and satisfy that policy. The \"WK\" method uses TPM2_MakeCredential() via tpm2-tools' tpm2 makecredential command, using the none TCTI (i.e., implemented in software). The target's EKpub is used as the handle input parameter to TPM2_MakeCredential() . A well-known key ( WK ), and the desired policy (if any) are used to compute the cryptographic name of the \"activation object\" ( objectName ) input parameter to TPM2_MakeCredential() . Decryption consists of calling TPM2_ActivateCredential() with the handle to the WK as the activationHandle input parameter, and the EK as the keyHandle input parameter of TPM2_ActivateCredential() . If a policy is desired then the adminWithPolicy attribute will be set on the WKname , which will cause TPM2_ActivateCredential() to require that the policy be satisfied. The \"TK\" method uses TPM2_Duplicate() via tpm2-tools' tpm2 duplicate command using the none TCTI (i.e., implemented in software. An RSA keypair is generated and its private key is exported to the target TPM using TPM2_Duplicate() -- we call this the \"transport key\", the TK . The small secret will then be encrypted to the TK 's public key ( TKpub ). Decryption works by importing the exported TK and then using TPM2_RSA_Decrypt() to decrypt the small secret encrypted to the TKpub .","title":"Encryption"},{"location":"attest-enroll/#encryption-of-larger-secrets","text":"In all cases, regardless of a secret's size, we use sbin/tpm2-send to encrypt an ephemeral, random AES-256 key to the target's TPM, then we encrypt the actual secret in that AES key in confounded AES-256-CBC-HMAC-SHA-256 cipher mode. The final ciphertext consists of those two ciphertexts: the one generated by sbin/tpm2-send and the one generated by AES encryption. Encryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: prepending a full cipher block of random bits (the \"confounder\") to the plaintext, encrypting the plaintext in AES-256 in cipher block chaining (CBC) mode with padding and zero IV, appending the HMAC of the resulting ciphertext using SHA-256 as the hash function for HMAC. Decryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: computing the HMAC-SHA-256 of the ciphertext excluding the MAC, checking that the HMAC of the ciphertext matches the HMAC in the ciphertext, decryption of the ciphertext using AES-256 in CBC with zero IV, removing the first full cipher block of the plaintext (the \"confounder\"), removing the padding. The confounder serves mainly to function as a sort of explicit random IV while allowing us to use a zero IV in the openssl enc command invocations. Since all of this is implemented in bash with openssl , and OpenSSL does not provide a decent authenticated encryption mode for AES, we script the confounded AES-256-CBC-HMAC-SHA-256 cipher mode, which turns out to be simple and elegant in bash. With OpenSSL 3.0 we could use ciphertext stealing mode (CTS) instead of CBC, and then we'd be using exactly the same more as Kerberos uses (confounded CTS with HMAC). The CTS cipher mode is a variant of CBC mode that avoids the need for padding, in exchange for which advantage CTS requires plaintexts to be at least one full cipher block (16 bytes) long, thus CTS is always used with a confounder, and the confounder functions as an explicit IV that allows the external IV to be zero.","title":"Encryption of Larger Secrets"},{"location":"attestation/","text":"When the user wants to connect to another computer over the network, they typicaly authenticate with a password and some sort of two factor token to prove to the remote system that they are authorized to make the connection. In high assurance applications, however, it is also important that the local computer be able to attest to the remote server that the local computer itself is both authorized and is also in a known configuration. The TPM provides a mechanism to do this sort of remote attestation, similar to the way that the disk encryption keys are \" sealed \" based on the PCRs and only decrypted if the platform configuration matches the sealed values. The tpm2-tools package has many of the pieces, but it is at too low a level for humans to use. Other parts of the validation exist in the openssl package, but again are not easily used and require format conversions from the TPM formats. tpm2-attest attempts to wrap all of the various parts of those two packages into a simple script that provides the four main attestation functions: sign a quote, validate a signed quote, seal a secret for a specific TPM, and unseal it with that TPM. Related to this is attest-enroll , a script that enrolls a device (e.g., a laptop, a server, etc.) given just its TPM's endorsement key's public key ( EKpub ) and a name. Enrollment can produce and encrypt to that EKpub any number of long-term secrets that are later sent to that device during successful attestation. tl;dr Enroll: extract EKpub , pick a device name run attest-enroll (typically via an HTTP API) with that EKpub and name Attest: Client: tpm2-attest > quote.tar Client: Send quote.tar to server (typically via an HTTP API) Server: tpm2-attest verify quote.tar | attest-verify to verify the client's state Server: tpm2-attest seal quote.tar < enrolled-secrets.tar > cipher.bin Server: Send cipher.bin to client Client: tpm2-attest unseal < cipher.bin > enrolled-secrets.tar Client: use tpm2-recv to decrypt long-term secrets in enrolled-secrets.tar Attestation protocol sequenceDiagram participant TPM participant Client participant Server as Attestation Server participant DB as Attestation Database TPM->>Client: EK, AK, Quote Client->>Server: EK, AK, Quote, eventlog Server->>DB: Hash EKpub, eventlog DB->>Server: TK and encrypted data Server->>Client: reply.tar: CK, TK, data Client->>TPM: activatecredential with AK TPM->>Client: Decrypted CK Client->>TPM: Load TK Client->>TPM: TK Encrypted data TPM->>Client: Decrypted data Client->>Server: Success The protocol requires a one round-trip between the local machine (the client) and the remote attestation server), and all comunication between the Client and the Server can be in the clear. There is no sensitive data exchanged -- the quote.tar file contains only public keys and PCR values that are essentially public, and the cipher.bin reply is encrypted with the TPM's Endorsement Key, so it should only be unsealable by that specific TPM. A MITM could substitute a different EK/AK pair, although this does not allow them to masquarade as the TPM of the attesting machine since they do not have the EK for that TPM, and the real TPM won't be able to decrypt the response from the attestation server since it would be encrypted with the wrong EK. The keys involved are: CA Root, stored hopefully securely by the CA TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM TPM Endorsement key ( EK ), an encryption key, generated in the TPM(?) and stored in the TPM hardware device TPM Endorsement certificate ( ek.crt ), signed by the TPM manufacturer, often stored in the TPM NVRAM Attestation Key ( AK ), a ephemeral signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes Credential Key ( CK ), an ephemeral symmetric encryption key used to protect the reply from the server, encrypted with the EK and tied to the AK so that only that TPM will decrypt it, and only if the AK is a valid key. Transport Key ( TK ), a long-term TPM duplicate key used to protect the attestation data. It is stored in the attestation database and encrypted with the client machine's EK , and has a policy that allows it to be used only once. There are two protocols: enrollment, and attestation. Each protocol is one round trip. Enrollment sequenceDiagram participant Admin participant Server as Enrollment Server participant DB as Attestation Database Admin->>Server: client 'EKpub'<br/> `EKcert`<br/> hostname<br/> Other data Note right of Server: validate `EKpub` against `EKcert`<br/> Generate TK Server->>DB: `EKpub`<br/> hostname<br/> `TK` (encrypted with `EK`) Note left of DB: Indexed by `sha256(EKpub)` An administrator, or the client itself, sends the client's EKpub and desired hostname to the enrollment server. The enrollment server checks that the client's enrolled state does not exist, then it creates it. See sbin/attest-enroll . The enrolled state consists of secrets encrypted to the client's EKpub and cleartext metadata. Attestation sequenceDiagram participant TPM participant Client participant Server as Attestation Server TPM->>Client: EKpub, Ephemeral AK Client->>TPM: Time since epoch TPM->>Client: Quote of all PCRs and time, signed with AK Note right of Client: Extract eventlog Client->>Server: quote.tar:<br/>EKpub and cert<br/> AK<br/> Quote (signed with AK)<br/> eventlog Client creates an Attestation Key ( AK ), quotes all the PCRs and current time, and sends its EKpub , AKpub , quote, and eventlog to the server. This is done with tpm2-attest quote > quote.tar sequenceDiagram participant Client participant Server as Attestation Server participant DB as Attestation Database Client->>Server: quote.tar Note right of Server: Validate signature on Quote Note right of Server: Validate eventlog matches quote Note right of Server: Validate time stamp is recent Server->>DB: Hash EKpub, eventlog Note left of DB: Validate policy on eventlog and PCRs DB->>Server: TK (encrypted with EK)<br/> Attestation data (encrypted with TK) Note right of Server: Create ephemeral credential key CK Note right of Server: Encrypt TK (encrypted with EK) with CK Note right of Server: makecredential with EK+AK and CK (no TPM required) Server->>Client: reply.tar:<br/>Credential blob<br/>(CK, encrypted with the EK / AK)<br/> TK encrypted with EK and credential key<br/> Attestation data (encrypted with TK) The server checks the quote, calls TPM2_MakeCredential() with the AKpub as the activation object, the EKpub as the key to encrypt to, and an AES-256 session key, and sends back the output as well as the enrolled state encrypted in that AES-256 session key. This is done with tpm2-attest verify | attest-verify | tpm2-attest seal sequenceDiagram participant TPM participant Client participant Server as Attestation Server Server->>Client: reply.tar Client->>TPM: activatecredential with AK Note right of TPM: validate AK, decrypt with EK TPM->>Client: Unsealed CK Note right of Client: Decrypt TK (encrypted with EK) with CK Client->>TPM: Load TK (encrypted with EK) TPM->>Client: TK context Client->>TPM: TK policy<br> Attestation data encrypted with TK Note right of TPM: validate TK policy<br>Decrypt data with TK TPM->>Client: Decrypted attestation data Client->>Server: Optionally report success The client recovers the AES-256 session key using TPM2_ActivateCredential() and then decrypts the secrets in its enrolled state. This is done with: tpm2-attest unseal then tpm2-recv for each secret. An optional second round-trip allows the client to prove possession of the EK and AK , and this can be used for logging the client's attestation status. Quote validation When the Server receives the quote file from the client, it runs: tpm2-attest verify quote.tar $nonce With this command the server will: Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client) Server optionally consults its list of previously enrolled devices to verify that this EK is in an owner controlled machine Server optionally validates that the PCRs match the expected values Server optoinally validates that the TPM event log produces the set of PCR values in the quote If the command fails, then something is likely wrong on the Client side and requires remediation. The Server should not proceed to sealing a secret for the Client. Suprisingly, the Attestation Key is not signed by the Endorsement Key, so the Server has to check the EK certificate to ensure that it came from a real TPM. Additional, the Server must check the AK attributes to ensure that it has fixedtpm and sensitivedataorigin set, which indicates that the AK was generated inside the TPM. Even with these checks, the Server is still trusting that the TPM hardware implements tpm2_activatecredential with all of these checks correctly done, since the sealed data is encrypted with the EK, not the AK. (Like many things with the TPM2, this is a really baroque way to organize the keys). Secret sealing Assuming the validation passed, the server can seal secret data such that only the TPM that produced the signed attestation will be able to unseal it, and has faith that the TPM will not unseal it if it has been reset (to prevent attacks that reboot into untrusted firmware): cat secret.txt | tpm2-attest seal quote.tar > cipher.bin With this command the Server will: Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK. The Server then sends this encrypted blob to the Client. Note that there is a verify-and-seal that combines both the quote validation and the sealing of the data to the attestation key in one step: cat secret.txt | tpm2-attest seal quote.tar $nonce > cipher.bin Secret unsealing Once the Client receives the sealed blob from the Server, it attempts to unseal it with the Attestation Key context that is left over from the initial quote signing: cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt With this command, the Client and TPM will: Initiates an encrypted session with the TPM and sends the blob to it. The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob. Client receives the secret message over the encrypted channel to the TPM At this point the Client can use the shared secret to authenticate to the Server, a network, or decrypt it's disk, or whatever. The TPM is no longer involved. TPM OEM Certificates A key part of the remote attestion is being able to trust that the TPM hardware is produced by a TPM manufacturer. Much like SSL Certs for websites, the TPM's Endorsement Key is signed by the OEM with their Intermediate CA, which is signed by a Root CA. Unlike SSL, the Root CAs are often not in the system's /etc/ssl/certs/ directory, and not easily accessible online. Some OEMs publish them in datasheets ( ST TPM EK certificates ), some have online portals to select per-device intermediate certs ( Infineon Optiga certificates ), and some just say \" Contact manufacturer for more details \" ( Atmel/Microchip EK Configuration ). Luckily Microsoft has a CAB file with all of their approved TPM OEMs in their guide to setting up shielded VMs . These x509 certs are in DER format ( and have a few odd ones ), so they have been converted to PEM and bundled into /etc/safeboot/certs/ for validating the TPM attestations. Adding new intermediate certificates If you add your own TPM keys to the directory, you will need to re-build the symlinks that OpenSSL uses for the -CApath : c_rehash /etc/safeboot/certs/ TPMs without EK certificates Unfortunately not all TPMs store their EK certs in the NVRAM; some of them require an online query to the OEM to generate the certificate. There is the tpm2_getmanufec program that is supposed to help with this process, although it hasn't been integrated into this tool yet. An alternative is to sign the EK with a key under your own control with tpm2-attest ek-sign . This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! tpm2 createek -c /dev/null -f PEM -u ek.pem tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ tpm2 nvdefine -s 1500 0x1c00002 tpm2 nvwrite -i ek.crt 0x1c00002 Google Cloud's ShieldedVM service enables vTPM for the guests, although it does not provide an EK in the NVRAM either. The key can be retrieved out of band with these instructions , or the public component can be read from the tpm2 createek command described above. Using the Google Cloud ShieldedVM lookup service can function as an EKcert as far as establishing trust in an instance's vTPM. Remote attestation demo Since the quote does not contain any clear text information and the response is sealed specifically for the TPM that generated the quote, a simple http server can be used to perform the attestion verification. A demo in sbin/attest-server performs this, using a fixed set of PCRs and a table of public key to secret mappings for the listed endorsement keys. On the server run: ./sbin/attest-server secrets.yaml And on the client: tpm2-attest attest http://server-name/ \\ > /tmp/secret.txt \\ || echo \"failed!\" FAQ Why is this a shell script? It is often desirable to perform a remote attestion inside of an initrd , where there aren't fancy runtimes for Python or more advanced languages. So the quote generation needs to be written assuming very limited resources, as does the response unsealing. The remote attestation server side could be implemented entirely in a more civilized language, especially since the Server does not require any TPM interaction at all -- all of its work is done in software and can be run as an ordinary user. As an example of moving some functionality into better languages, the tpm2-eventlog-validate tool that parses the TPM2 event log and generates expected PCR values is written in Python. I thought remote attestation and TPMs were only for DRM? One of the big fears in the free software community was that TPM's would be used to lockdown the devices and implement DRM. That hasn't developed in general purpose computers and mjg59's TPM guide concludes with \" the current state of technology doesn't make them useful for practical limitations of end-user freedom \". There's a far bigger threat to user freedom in the locked-down world of mobile devices; currently most x86 machines allow rekeying with user keys, so the software (but not the firmware) is still under owner control. Remote Attestation can be used bidirectionally as well - it allows the server to attest to the client that the machine is in a trustworthy state. This is perhaps an even more valuable use case: you might have fairly tight physical control of your personal machine, but a bare metal server in a data center is potentially open to attacks by the cloud operator as well as the previous tenants. Having attestations as to the firmware and the OS configuration can make it more trustable. Why is generating a quote so slow? There is lots of traffic between the tpm2-attest program and the TPM during the attestation process, and the TPM is not a fast device. Read the Endorsement Key (EK) and EK Certificate take a few hundred miliseconds, signing the quote takes another few hundred, etc. The process used to take around 20 seconds, since the TPM had to generate a new RSA Attestation Key (AK) to sign the PCR quote, and generating an RSA key requires finding large primes with certain values. The AK was replaced with ECC, which is much faster to generate. Creating a new one each time should not be necessary; several attestation protocols use a pregenerated AK that is persistent in the TPM, except that opens up a race condition between generating a quote and receiving the sealed data. The quote includes the reboot count, but the sealed data does not reference it, so the TPM will unseal it if the AK is still valid, even if an attacker has rebooted into an untrustworthy state inbetween generating the quote and receiving the sealed response. By creating an ephemeral AK (with the stclear bit set in the attributes), the TPM will not allow it to be persisted and will refuse to reload it when the reboot counter increments. Discrete TPM vs fTPM? The Discrete TPM is potentially a hardware weakpoint; a physically proximate adversary could remove the TPM from a machine and connect it to an untrusted device and then masquarade as the device to which the TPM had been connected. This would also potentially allow them to extract any sealed disk encryption keys, as described on the threat model page , and is one of the advantages of an fTPM inside the Management Engine. A proximate attacker could also interfere with the LPC or i2c bus of a Discrete TPM using something like the TPM Genie , which allow them to both modify the hashes sent to the TPM during PCR extension operations, and read the unsealed secrets when they are returned if the TPM didn't support secret sessions. However, the fTPM is a pure-software application inside the ME and potentially allows an attacker with code execution on the ME to find the sealing secrets that are used to protect the TPM keys in the ME NVRAM, which would allow attacks against the quoting and attestation process.","title":"Remote Attestation"},{"location":"attestation/#tldr","text":"Enroll: extract EKpub , pick a device name run attest-enroll (typically via an HTTP API) with that EKpub and name Attest: Client: tpm2-attest > quote.tar Client: Send quote.tar to server (typically via an HTTP API) Server: tpm2-attest verify quote.tar | attest-verify to verify the client's state Server: tpm2-attest seal quote.tar < enrolled-secrets.tar > cipher.bin Server: Send cipher.bin to client Client: tpm2-attest unseal < cipher.bin > enrolled-secrets.tar Client: use tpm2-recv to decrypt long-term secrets in enrolled-secrets.tar","title":"tl;dr"},{"location":"attestation/#attestation-protocol","text":"sequenceDiagram participant TPM participant Client participant Server as Attestation Server participant DB as Attestation Database TPM->>Client: EK, AK, Quote Client->>Server: EK, AK, Quote, eventlog Server->>DB: Hash EKpub, eventlog DB->>Server: TK and encrypted data Server->>Client: reply.tar: CK, TK, data Client->>TPM: activatecredential with AK TPM->>Client: Decrypted CK Client->>TPM: Load TK Client->>TPM: TK Encrypted data TPM->>Client: Decrypted data Client->>Server: Success The protocol requires a one round-trip between the local machine (the client) and the remote attestation server), and all comunication between the Client and the Server can be in the clear. There is no sensitive data exchanged -- the quote.tar file contains only public keys and PCR values that are essentially public, and the cipher.bin reply is encrypted with the TPM's Endorsement Key, so it should only be unsealable by that specific TPM. A MITM could substitute a different EK/AK pair, although this does not allow them to masquarade as the TPM of the attesting machine since they do not have the EK for that TPM, and the real TPM won't be able to decrypt the response from the attestation server since it would be encrypted with the wrong EK. The keys involved are: CA Root, stored hopefully securely by the CA TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM TPM Endorsement key ( EK ), an encryption key, generated in the TPM(?) and stored in the TPM hardware device TPM Endorsement certificate ( ek.crt ), signed by the TPM manufacturer, often stored in the TPM NVRAM Attestation Key ( AK ), a ephemeral signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes Credential Key ( CK ), an ephemeral symmetric encryption key used to protect the reply from the server, encrypted with the EK and tied to the AK so that only that TPM will decrypt it, and only if the AK is a valid key. Transport Key ( TK ), a long-term TPM duplicate key used to protect the attestation data. It is stored in the attestation database and encrypted with the client machine's EK , and has a policy that allows it to be used only once. There are two protocols: enrollment, and attestation. Each protocol is one round trip.","title":"Attestation protocol"},{"location":"attestation/#enrollment","text":"sequenceDiagram participant Admin participant Server as Enrollment Server participant DB as Attestation Database Admin->>Server: client 'EKpub'<br/> `EKcert`<br/> hostname<br/> Other data Note right of Server: validate `EKpub` against `EKcert`<br/> Generate TK Server->>DB: `EKpub`<br/> hostname<br/> `TK` (encrypted with `EK`) Note left of DB: Indexed by `sha256(EKpub)` An administrator, or the client itself, sends the client's EKpub and desired hostname to the enrollment server. The enrollment server checks that the client's enrolled state does not exist, then it creates it. See sbin/attest-enroll . The enrolled state consists of secrets encrypted to the client's EKpub and cleartext metadata.","title":"Enrollment"},{"location":"attestation/#attestation","text":"sequenceDiagram participant TPM participant Client participant Server as Attestation Server TPM->>Client: EKpub, Ephemeral AK Client->>TPM: Time since epoch TPM->>Client: Quote of all PCRs and time, signed with AK Note right of Client: Extract eventlog Client->>Server: quote.tar:<br/>EKpub and cert<br/> AK<br/> Quote (signed with AK)<br/> eventlog Client creates an Attestation Key ( AK ), quotes all the PCRs and current time, and sends its EKpub , AKpub , quote, and eventlog to the server. This is done with tpm2-attest quote > quote.tar sequenceDiagram participant Client participant Server as Attestation Server participant DB as Attestation Database Client->>Server: quote.tar Note right of Server: Validate signature on Quote Note right of Server: Validate eventlog matches quote Note right of Server: Validate time stamp is recent Server->>DB: Hash EKpub, eventlog Note left of DB: Validate policy on eventlog and PCRs DB->>Server: TK (encrypted with EK)<br/> Attestation data (encrypted with TK) Note right of Server: Create ephemeral credential key CK Note right of Server: Encrypt TK (encrypted with EK) with CK Note right of Server: makecredential with EK+AK and CK (no TPM required) Server->>Client: reply.tar:<br/>Credential blob<br/>(CK, encrypted with the EK / AK)<br/> TK encrypted with EK and credential key<br/> Attestation data (encrypted with TK) The server checks the quote, calls TPM2_MakeCredential() with the AKpub as the activation object, the EKpub as the key to encrypt to, and an AES-256 session key, and sends back the output as well as the enrolled state encrypted in that AES-256 session key. This is done with tpm2-attest verify | attest-verify | tpm2-attest seal sequenceDiagram participant TPM participant Client participant Server as Attestation Server Server->>Client: reply.tar Client->>TPM: activatecredential with AK Note right of TPM: validate AK, decrypt with EK TPM->>Client: Unsealed CK Note right of Client: Decrypt TK (encrypted with EK) with CK Client->>TPM: Load TK (encrypted with EK) TPM->>Client: TK context Client->>TPM: TK policy<br> Attestation data encrypted with TK Note right of TPM: validate TK policy<br>Decrypt data with TK TPM->>Client: Decrypted attestation data Client->>Server: Optionally report success The client recovers the AES-256 session key using TPM2_ActivateCredential() and then decrypts the secrets in its enrolled state. This is done with: tpm2-attest unseal then tpm2-recv for each secret. An optional second round-trip allows the client to prove possession of the EK and AK , and this can be used for logging the client's attestation status.","title":"Attestation"},{"location":"attestation/#quote-validation","text":"When the Server receives the quote file from the client, it runs: tpm2-attest verify quote.tar $nonce With this command the server will: Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client) Server optionally consults its list of previously enrolled devices to verify that this EK is in an owner controlled machine Server optionally validates that the PCRs match the expected values Server optoinally validates that the TPM event log produces the set of PCR values in the quote If the command fails, then something is likely wrong on the Client side and requires remediation. The Server should not proceed to sealing a secret for the Client. Suprisingly, the Attestation Key is not signed by the Endorsement Key, so the Server has to check the EK certificate to ensure that it came from a real TPM. Additional, the Server must check the AK attributes to ensure that it has fixedtpm and sensitivedataorigin set, which indicates that the AK was generated inside the TPM. Even with these checks, the Server is still trusting that the TPM hardware implements tpm2_activatecredential with all of these checks correctly done, since the sealed data is encrypted with the EK, not the AK. (Like many things with the TPM2, this is a really baroque way to organize the keys).","title":"Quote validation"},{"location":"attestation/#secret-sealing","text":"Assuming the validation passed, the server can seal secret data such that only the TPM that produced the signed attestation will be able to unseal it, and has faith that the TPM will not unseal it if it has been reset (to prevent attacks that reboot into untrusted firmware): cat secret.txt | tpm2-attest seal quote.tar > cipher.bin With this command the Server will: Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK. The Server then sends this encrypted blob to the Client. Note that there is a verify-and-seal that combines both the quote validation and the sealing of the data to the attestation key in one step: cat secret.txt | tpm2-attest seal quote.tar $nonce > cipher.bin","title":"Secret sealing"},{"location":"attestation/#secret-unsealing","text":"Once the Client receives the sealed blob from the Server, it attempts to unseal it with the Attestation Key context that is left over from the initial quote signing: cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt With this command, the Client and TPM will: Initiates an encrypted session with the TPM and sends the blob to it. The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob. Client receives the secret message over the encrypted channel to the TPM At this point the Client can use the shared secret to authenticate to the Server, a network, or decrypt it's disk, or whatever. The TPM is no longer involved.","title":"Secret unsealing"},{"location":"attestation/#tpm-oem-certificates","text":"A key part of the remote attestion is being able to trust that the TPM hardware is produced by a TPM manufacturer. Much like SSL Certs for websites, the TPM's Endorsement Key is signed by the OEM with their Intermediate CA, which is signed by a Root CA. Unlike SSL, the Root CAs are often not in the system's /etc/ssl/certs/ directory, and not easily accessible online. Some OEMs publish them in datasheets ( ST TPM EK certificates ), some have online portals to select per-device intermediate certs ( Infineon Optiga certificates ), and some just say \" Contact manufacturer for more details \" ( Atmel/Microchip EK Configuration ). Luckily Microsoft has a CAB file with all of their approved TPM OEMs in their guide to setting up shielded VMs . These x509 certs are in DER format ( and have a few odd ones ), so they have been converted to PEM and bundled into /etc/safeboot/certs/ for validating the TPM attestations.","title":"TPM OEM Certificates"},{"location":"attestation/#adding-new-intermediate-certificates","text":"If you add your own TPM keys to the directory, you will need to re-build the symlinks that OpenSSL uses for the -CApath : c_rehash /etc/safeboot/certs/","title":"Adding new intermediate certificates"},{"location":"attestation/#tpms-without-ek-certificates","text":"Unfortunately not all TPMs store their EK certs in the NVRAM; some of them require an online query to the OEM to generate the certificate. There is the tpm2_getmanufec program that is supposed to help with this process, although it hasn't been integrated into this tool yet. An alternative is to sign the EK with a key under your own control with tpm2-attest ek-sign . This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! tpm2 createek -c /dev/null -f PEM -u ek.pem tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ tpm2 nvdefine -s 1500 0x1c00002 tpm2 nvwrite -i ek.crt 0x1c00002 Google Cloud's ShieldedVM service enables vTPM for the guests, although it does not provide an EK in the NVRAM either. The key can be retrieved out of band with these instructions , or the public component can be read from the tpm2 createek command described above. Using the Google Cloud ShieldedVM lookup service can function as an EKcert as far as establishing trust in an instance's vTPM.","title":"TPMs without EK certificates"},{"location":"attestation/#remote-attestation-demo","text":"Since the quote does not contain any clear text information and the response is sealed specifically for the TPM that generated the quote, a simple http server can be used to perform the attestion verification. A demo in sbin/attest-server performs this, using a fixed set of PCRs and a table of public key to secret mappings for the listed endorsement keys. On the server run: ./sbin/attest-server secrets.yaml And on the client: tpm2-attest attest http://server-name/ \\ > /tmp/secret.txt \\ || echo \"failed!\"","title":"Remote attestation demo"},{"location":"attestation/#faq","text":"","title":"FAQ"},{"location":"attestation/#why-is-this-a-shell-script","text":"It is often desirable to perform a remote attestion inside of an initrd , where there aren't fancy runtimes for Python or more advanced languages. So the quote generation needs to be written assuming very limited resources, as does the response unsealing. The remote attestation server side could be implemented entirely in a more civilized language, especially since the Server does not require any TPM interaction at all -- all of its work is done in software and can be run as an ordinary user. As an example of moving some functionality into better languages, the tpm2-eventlog-validate tool that parses the TPM2 event log and generates expected PCR values is written in Python.","title":"Why is this a shell script?"},{"location":"attestation/#i-thought-remote-attestation-and-tpms-were-only-for-drm","text":"One of the big fears in the free software community was that TPM's would be used to lockdown the devices and implement DRM. That hasn't developed in general purpose computers and mjg59's TPM guide concludes with \" the current state of technology doesn't make them useful for practical limitations of end-user freedom \". There's a far bigger threat to user freedom in the locked-down world of mobile devices; currently most x86 machines allow rekeying with user keys, so the software (but not the firmware) is still under owner control. Remote Attestation can be used bidirectionally as well - it allows the server to attest to the client that the machine is in a trustworthy state. This is perhaps an even more valuable use case: you might have fairly tight physical control of your personal machine, but a bare metal server in a data center is potentially open to attacks by the cloud operator as well as the previous tenants. Having attestations as to the firmware and the OS configuration can make it more trustable.","title":"I thought remote attestation and TPMs were only for DRM?"},{"location":"attestation/#why-is-generating-a-quote-so-slow","text":"There is lots of traffic between the tpm2-attest program and the TPM during the attestation process, and the TPM is not a fast device. Read the Endorsement Key (EK) and EK Certificate take a few hundred miliseconds, signing the quote takes another few hundred, etc. The process used to take around 20 seconds, since the TPM had to generate a new RSA Attestation Key (AK) to sign the PCR quote, and generating an RSA key requires finding large primes with certain values. The AK was replaced with ECC, which is much faster to generate. Creating a new one each time should not be necessary; several attestation protocols use a pregenerated AK that is persistent in the TPM, except that opens up a race condition between generating a quote and receiving the sealed data. The quote includes the reboot count, but the sealed data does not reference it, so the TPM will unseal it if the AK is still valid, even if an attacker has rebooted into an untrustworthy state inbetween generating the quote and receiving the sealed response. By creating an ephemeral AK (with the stclear bit set in the attributes), the TPM will not allow it to be persisted and will refuse to reload it when the reboot counter increments.","title":"Why is generating a quote so slow?"},{"location":"attestation/#discrete-tpm-vs-ftpm","text":"The Discrete TPM is potentially a hardware weakpoint; a physically proximate adversary could remove the TPM from a machine and connect it to an untrusted device and then masquarade as the device to which the TPM had been connected. This would also potentially allow them to extract any sealed disk encryption keys, as described on the threat model page , and is one of the advantages of an fTPM inside the Management Engine. A proximate attacker could also interfere with the LPC or i2c bus of a Discrete TPM using something like the TPM Genie , which allow them to both modify the hashes sent to the TPM during PCR extension operations, and read the unsealed secrets when they are returned if the TPM didn't support secret sessions. However, the fTPM is a pure-software application inside the ME and potentially allows an attacker with code execution on the ME to find the sealing secrets that are used to protect the TPM keys in the ME NVRAM, which would allow attacks against the quoting and attestation process.","title":"Discrete TPM vs fTPM?"},{"location":"chain-of-trust/","text":"Chain of Trust Booting a modern x86 CPU is no longer as simple as it used to be. This page attempts to document the entire chain of trust and keys involved in securing the boot process. It is based on reverse engineered and observed behaviour, so it may not be entirely accurate. Hopefully it is still helpful. Keys and certificates Intel's ME public key hash on die Intel's ME public key stored in flash Intel's ucode symmetric key (burned into the CPU?) Intel's ucode public key hash (burned into the CPU?) Intel's ucode public key stored in ucode file in the flash Intel's ACM public key hash (in CPU and updatable in microcode?) Intel's ACM public key in the ACM header OEM Key Manifest Security Version Number (KMSVN, stored in fuses in PCH) OEM root public key hash (OTP fuses in the PCH, delivered from ME to x86) Bootguard Key Manifest (with KMSVN to protect against rollback) signed by OEM public key OEM root public key in the Bootguard Key Manifest in the flash OEM per-model public key stored in Bootguard Key Manifest Bootguard Boot Policy, signed by OEM per-model public key Bootguard region hashes, stored in Bootguard Boot Policy UEFI Platform Key (PK) / Key Exchange Key (KEK) / Database keys (DB) / Revocation Database (DBX) CA root key TPM OEM root certificate TPM OEM intermediate certificate TPM Endorsement Key TPM Attestation Key Linux kernel keyring ME Startup As soon as power is available, the ME boots up from its on-die boot ROM, checks some straps and fuses to determine its configuration, and typically then copies the flash partition table from the ME region of the flash to its on-die SRAM (although ROMB fused chips have limited security). The boot ROM locates the FTPR partition and copies it from the SPI flash into the on-die SRAM. It then checks that the SHA-1 hash of the key stored in the parition manifest matches the one in its on-die ROM and validates the RSA signature on the rest of the partition manifest. The partition table contains hashes of each of the modules in the partition, allowing the modules to be validated after they are copied into the on-die SRAM for execution ( Intel ME Flash File System Explained - Sklyarov et al, BH-EU 2017). x86 ucode and ACM When the ME starts the clocks for the x86 CPU, the on-die microcode fetches the Firmware Interface Table (FIT) pointer at 0xFFFFFFC0 which points to the FIT table somewhere in the SPI flash image. This table is then searched for microcode updates that match the CPU ID. The current microcode copies them from flash in a linear fashion (into L3 cache?) and decrypts with an on-die symmetric AES key ( Chen & Ahn 2014 ), then validates with (on-die?) RSA key. It's likely that these ucode updates also contain the key hashes for the ACM. Next the x86 ucode goes back to the FIT to find the Startup ACM and does an odd copy of it into L3 (looks like multiple hyperthreads are copying 4KB chunks?). The ACM contains an RSA public key; the ucode compares it against either an on-die key (hash?) or one stored in the ucode update and halts the CPU if it does not match. The ucode then checks the signature on the ACM and again halts if it does not match. The Startup ACM is supposed to run entirely out of L3, although there have been bugs ( Bosch & Hudson, 2019 ) that allowed a proximate attacker to use devices like the Spispy to detect accidental cache misses and TOCTOU the firmware. The ACM receives the OEM public key hash and Bootguard Profile from the ME via MSR. (Not certain of the order of operations here). The ACM reads the BootGuard Key Manifest from the SPI flash (pointed to by the FIT and identified by __KEYM__ ) into L3 and hashes the RSA public key stored in it. If it doesn't match the OEM public key hash or if the OEM public key signature on the Key Manifest or if the stored KmSvn isn't right, the ACM takes action based on the Bootguard Profile bits. If it does match, it locates the Bootguard Policy in the FIT (and identified by __ACBP__ ) and copies it into L3. The ACM then computes the hash of the RSA public key in the Policy and compares it to the SHA256 hash stored in the Key Manifest. If that fails to match, or if the RSA signature on the Policy doesn't match, then the ACM again takes action based on the Profile settings. The ACM uses the now validated Bootguard Policy structure to read the Initial Boot Block (IBB) segments into L3, hashing them as they are copied (and hopefully not causing any cache misses). If this computed hash doesn't match the \"IBB Digest\" in the Policy, the ACM takes action based on the Profile settings. UEFI After some parts of the UEFI firmware are hashed and validated by BootGuard, the ACM executes a GETSEC instruction to jump to either the legacy reset vector at 0xFFFFFFF0 or the address in the BootGuard manifest. This is typically in the PEI firmware volume and in the SecCore.efi executable with the VolumeTopFile GUID. At this point the chain of trust is now controlled by the OEM and they are responsible for validating the rest of the firmware. Usually they will jump into the Intel FSP to initialze DRAM (on AMD the PSP has initialized DRAM prior to starting the BIOS, although they have a separate chain of trust entirely). Once DRAM is initialized, the SecCore copies the DXE firmware volumes from flash into RAM and computes their hashes. The major BIOS vendors (IBV) have their own data structures, such as the AMIHash or PhoenixHash, that are used to enumerate the regions to be hashed. This is another common area of TOCTOU attacks against the boot process. (Need to document when UEFI capsule updates are searched and when the PRR are locked to prevent further flash writes) The UEFI firmware stores non-volatile configuration data in the flash as well. These \"nvram variables\" are controlled by the computer owner and begin the chain of trust transition from the OEM to the owner. The SecureBoot variable tells the firmware if it should enable UEFI Secure Boot. If it is set, then the firmware will attempt to enforce the secure boot policy. To do this it has a Platform Key ( PK ), which signs the Key-Exchange-Key ( KEK ), which signs entries in the key database ( db ) as well as key revocation entries ( dbx ). Typically the PK and KEK are OEM keys (I think) and the db is preloaded with Microsoft's key. Linux distributions and tools like grub have paid Microsoft to sign their bootloaders, which allow them to boot on commodity systems with UEFI Secure Boot enabled. It is also possible to replace these keys, and the safeboot project loads an owner controlled key into the PK to ensure that only owner signed code will be booted. However, before the firmware can locate the boot disk, which might be SATA, NVME, USB, or network, it needs to initialize the hardware and possibly load Option ROMs from devices to configure them. These Options ROMs are literally x86 code that is run in ring 0 while the system is still in a very vulnerable state, so it is important that they be signed. Option ROMs have been an easy vulnerability for local attackers for many years (Heasman BH'07, snare BH'12, Hudson 31C3/BH'15). Once the devices have been initialized, UEFI transitions to the Boot Device Selector phase ( BDS ), which uses the nvram variables BootNext , Boot0000 , Boot0001 , etc to determine which boot loader to use. The BDS also calls bs->ExitBootServices() to tell the firmware that the OS is about to start, which locks some of the firmware variables from further updates. Linux (To be added: shim protocol?) Linux has a kernel key ring that is loaded at boot time with the UEFI keys as well as a compile-time key. It validates kernel modules with this key. (To be written) TPM (To be written)","title":"Chain of Trust"},{"location":"chain-of-trust/#chain-of-trust","text":"Booting a modern x86 CPU is no longer as simple as it used to be. This page attempts to document the entire chain of trust and keys involved in securing the boot process. It is based on reverse engineered and observed behaviour, so it may not be entirely accurate. Hopefully it is still helpful.","title":"Chain of Trust"},{"location":"chain-of-trust/#keys-and-certificates","text":"Intel's ME public key hash on die Intel's ME public key stored in flash Intel's ucode symmetric key (burned into the CPU?) Intel's ucode public key hash (burned into the CPU?) Intel's ucode public key stored in ucode file in the flash Intel's ACM public key hash (in CPU and updatable in microcode?) Intel's ACM public key in the ACM header OEM Key Manifest Security Version Number (KMSVN, stored in fuses in PCH) OEM root public key hash (OTP fuses in the PCH, delivered from ME to x86) Bootguard Key Manifest (with KMSVN to protect against rollback) signed by OEM public key OEM root public key in the Bootguard Key Manifest in the flash OEM per-model public key stored in Bootguard Key Manifest Bootguard Boot Policy, signed by OEM per-model public key Bootguard region hashes, stored in Bootguard Boot Policy UEFI Platform Key (PK) / Key Exchange Key (KEK) / Database keys (DB) / Revocation Database (DBX) CA root key TPM OEM root certificate TPM OEM intermediate certificate TPM Endorsement Key TPM Attestation Key Linux kernel keyring","title":"Keys and certificates"},{"location":"chain-of-trust/#me-startup","text":"As soon as power is available, the ME boots up from its on-die boot ROM, checks some straps and fuses to determine its configuration, and typically then copies the flash partition table from the ME region of the flash to its on-die SRAM (although ROMB fused chips have limited security). The boot ROM locates the FTPR partition and copies it from the SPI flash into the on-die SRAM. It then checks that the SHA-1 hash of the key stored in the parition manifest matches the one in its on-die ROM and validates the RSA signature on the rest of the partition manifest. The partition table contains hashes of each of the modules in the partition, allowing the modules to be validated after they are copied into the on-die SRAM for execution ( Intel ME Flash File System Explained - Sklyarov et al, BH-EU 2017).","title":"ME Startup"},{"location":"chain-of-trust/#x86-ucode-and-acm","text":"When the ME starts the clocks for the x86 CPU, the on-die microcode fetches the Firmware Interface Table (FIT) pointer at 0xFFFFFFC0 which points to the FIT table somewhere in the SPI flash image. This table is then searched for microcode updates that match the CPU ID. The current microcode copies them from flash in a linear fashion (into L3 cache?) and decrypts with an on-die symmetric AES key ( Chen & Ahn 2014 ), then validates with (on-die?) RSA key. It's likely that these ucode updates also contain the key hashes for the ACM. Next the x86 ucode goes back to the FIT to find the Startup ACM and does an odd copy of it into L3 (looks like multiple hyperthreads are copying 4KB chunks?). The ACM contains an RSA public key; the ucode compares it against either an on-die key (hash?) or one stored in the ucode update and halts the CPU if it does not match. The ucode then checks the signature on the ACM and again halts if it does not match. The Startup ACM is supposed to run entirely out of L3, although there have been bugs ( Bosch & Hudson, 2019 ) that allowed a proximate attacker to use devices like the Spispy to detect accidental cache misses and TOCTOU the firmware. The ACM receives the OEM public key hash and Bootguard Profile from the ME via MSR. (Not certain of the order of operations here). The ACM reads the BootGuard Key Manifest from the SPI flash (pointed to by the FIT and identified by __KEYM__ ) into L3 and hashes the RSA public key stored in it. If it doesn't match the OEM public key hash or if the OEM public key signature on the Key Manifest or if the stored KmSvn isn't right, the ACM takes action based on the Bootguard Profile bits. If it does match, it locates the Bootguard Policy in the FIT (and identified by __ACBP__ ) and copies it into L3. The ACM then computes the hash of the RSA public key in the Policy and compares it to the SHA256 hash stored in the Key Manifest. If that fails to match, or if the RSA signature on the Policy doesn't match, then the ACM again takes action based on the Profile settings. The ACM uses the now validated Bootguard Policy structure to read the Initial Boot Block (IBB) segments into L3, hashing them as they are copied (and hopefully not causing any cache misses). If this computed hash doesn't match the \"IBB Digest\" in the Policy, the ACM takes action based on the Profile settings.","title":"x86 ucode and ACM"},{"location":"chain-of-trust/#uefi","text":"After some parts of the UEFI firmware are hashed and validated by BootGuard, the ACM executes a GETSEC instruction to jump to either the legacy reset vector at 0xFFFFFFF0 or the address in the BootGuard manifest. This is typically in the PEI firmware volume and in the SecCore.efi executable with the VolumeTopFile GUID. At this point the chain of trust is now controlled by the OEM and they are responsible for validating the rest of the firmware. Usually they will jump into the Intel FSP to initialze DRAM (on AMD the PSP has initialized DRAM prior to starting the BIOS, although they have a separate chain of trust entirely). Once DRAM is initialized, the SecCore copies the DXE firmware volumes from flash into RAM and computes their hashes. The major BIOS vendors (IBV) have their own data structures, such as the AMIHash or PhoenixHash, that are used to enumerate the regions to be hashed. This is another common area of TOCTOU attacks against the boot process. (Need to document when UEFI capsule updates are searched and when the PRR are locked to prevent further flash writes) The UEFI firmware stores non-volatile configuration data in the flash as well. These \"nvram variables\" are controlled by the computer owner and begin the chain of trust transition from the OEM to the owner. The SecureBoot variable tells the firmware if it should enable UEFI Secure Boot. If it is set, then the firmware will attempt to enforce the secure boot policy. To do this it has a Platform Key ( PK ), which signs the Key-Exchange-Key ( KEK ), which signs entries in the key database ( db ) as well as key revocation entries ( dbx ). Typically the PK and KEK are OEM keys (I think) and the db is preloaded with Microsoft's key. Linux distributions and tools like grub have paid Microsoft to sign their bootloaders, which allow them to boot on commodity systems with UEFI Secure Boot enabled. It is also possible to replace these keys, and the safeboot project loads an owner controlled key into the PK to ensure that only owner signed code will be booted. However, before the firmware can locate the boot disk, which might be SATA, NVME, USB, or network, it needs to initialize the hardware and possibly load Option ROMs from devices to configure them. These Options ROMs are literally x86 code that is run in ring 0 while the system is still in a very vulnerable state, so it is important that they be signed. Option ROMs have been an easy vulnerability for local attackers for many years (Heasman BH'07, snare BH'12, Hudson 31C3/BH'15). Once the devices have been initialized, UEFI transitions to the Boot Device Selector phase ( BDS ), which uses the nvram variables BootNext , Boot0000 , Boot0001 , etc to determine which boot loader to use. The BDS also calls bs->ExitBootServices() to tell the firmware that the OS is about to start, which locks some of the firmware variables from further updates.","title":"UEFI"},{"location":"chain-of-trust/#linux","text":"(To be added: shim protocol?) Linux has a kernel key ring that is loaded at boot time with the UEFI keys as well as a compile-time key. It validates kernel modules with this key. (To be written)","title":"Linux"},{"location":"chain-of-trust/#tpm","text":"(To be written)","title":"TPM"},{"location":"faq/","text":"Frequently Asked Questions What is the threat model? safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. More details are in the threat model page . How is this better than normal UEFI Secure Boot? safeboot is not a replacement for UEFI SecureBoot - the two work together to improve the security of the system. SecureBoot ensures that the boot firmware is measured into the TPM and validates the signatures on the Linux kernel and initrd, and safeboot adds additional integrity protections beyond that. The default UEFI Secure Boot configuration is sufficient for Microsoft's needs since they are the only signing authority for their runtime, while Linux computer owners frequently want to compile their own kernel or runtime. The compromise solution developed by Linux distributions has Microsoft sign a \"shim\" bootloader that has its own key management. Since most distributions have their keys enrolled in the shim, systems that have Secure Boot enabled will boot the distribution's ISOs, which might not be desirable since it potentially gives an adversary runtime access to unencrypted parts of the system. A larger problem is that by default only the Linux kernel is signed, not the command line parameters or initrd. While the grub bootloader can enable a password to protect against casual changes to the kernel parameters, the grub.cfg configuration is not typically signed. This means that potentially a local attacker can modify it on disk to launch the kernel with init=/bin/sh to drop into a shell, or an attacker with root access can add trojan'ed binaries to the initrd to gain persistence. By replacing the Platform Key and removing grub , only Linux kernel and initrd images signed by the computer owner will boot. Far more details on how safeboot extends UEFI SecureBoot are on the threat model page . Does safeboot have a BootHole? BootHole ( CVE-2020-10713 ), is a vulnerability found and described by Eclypsium ) in grub 's configuration file parsing which allows arbitrary code execution in grub even when Secure Boot is enabled. Kelly Shortridge has a good writeup by at capsule8 that explains how this threat could be leveraged by an attacker and the difficulties in doing so in a general case, although an attacker with physical access is able to write to the internal disk and could launch this attack. Since these sorts of physical attacks are included in the safeboot threat model , it is worth considering. However, a system using safeboot is not vulnerable to CVE-2020-10713 since grub is not used at all and will not be run even if it is present on the disk. During the safeboot installation process, the system owner replaces the UEFI Platform Key with their own , which prevents the Microsoft signed shim used by grub from being loaded, and they then create efibootmgr entries for linux and recovery that are signed with their (hardware protected) key. Assuming there are not vulnerabilities in the system's UEFI firmware or CPU vendor's BootGuard (which may not be the best assumption...), the safeboot configuration should ensure that only signed kernel, initrd, and command lines will be booted by the system. This static chain of trust helps prevent attacks on grub like BootHole, or other ones that modify on-disk data, from being able to gain persistence or code execution. One caveat to the protection provided by the UEFI Secure Boot Platform Keys is that the UEFI NVRAM configuration data is stored in the SPI flash and is also subject to modifications by a physically proximate attacker with internal access to the hardware. However, if the attacker uses a flash programmer to change the Platform Keys in the flash, the TPM measurements of the Setup variable will be different and the TPM should refuse to unseal the disk encryption key since the PCR values will not match the sealed ones. The adversary might try to roll back to an vulnerable version of the kernel and the earlier signed PCRs, but the TPM will refuse to unseal since monotonic counter value will not match the signed one. An adversary might create a fake PIN entry screen to try to harvest the unsealing PIN or the recovery key, although in any of these cases, the TPM TOTP six-digit authenicator value will not be correct since the TPM will not unseal it with modified firmware. Additionally the system should fail remote attestation if it attempts to connect to a server that validates the TPM quote, improving platform resiliency even when attackers do gain persistence. How does safeboot compare to coreboot? coreboot is entirely free software and can provide far better control of the boot process, although it is not supported on as many modern platforms as UEFI SecureBoot and requires reprogramming the SPI flash on the device. If you have a machine that supports both coreboot and Bootguard, then you're probably better off running it instead. However, be prepared to spend quite a bit of quality time with your SPI flash programmer to get it working... Once coreboot or UEFI hand off to the Linux kernel, the TPM unsealing of the disk encryption key, the dmverity protections on the root filesystem and the lockdown patches work the same. Does safeboot work with AMD cpus? It has only been tested on the Intel systems with Bootguard. The UEFI platform keys and the rest of the lock down should work with AMD, although AMD's hardware secured boot process hasn't been reviewed as extensively as Intel's ME and Bootguard. For an indepth analysis of the AMD Platform Support Processor (PSP) and SEV, Buhren, Eichner and Werling's 35c3 presentation is the most detailed look so far. Does safeboot work with Qubes or Xen? Qubes, a reasonably secure OS, uses the Xen hypervisor to separate device drivers and applications into separate virtual machines so that an exploit against an individual component doesn't necessarily compromise the entire machine. Unfortunately Xen's EFI support is not commonly used, and as a result running Qubes typically requires Legacy BIOS and turning off Secure Boot. Adding Secure Boot support to Xen is possible with some patches ( safeboot-issue #21 ), although it is a work in progress. There are other factors involved in configuring Qubes to use dm-verity and TPM sealed secrets that have not been addressed yet, as well as an open qubes-issue on distribution signing keys . What causes the TPM unsealing to fail? The TPM will only unseal the disk encryption key if: The policy is signed by the UEFI platform key. The PCRs in $PCRS match the ones computed by the TPM, which typically include the firmware, UEFI setup variable, UEFI key database, and the PE hash of the kernel + initrd. The boot mode PCR in $BOOTMODE_PCR matches the sha256 hash of the safeboot.mode= kernel command line parameter and has not been extended post-boot. The TPM monotonic counter in $TPM_NV_VERSION matches the one in the policy. The user PIN matches the on used to seal the data. These requirements are violated by several different attacks, although they can also fail if a new kernel is installed with safeboot linux-sign and safeboot pcrs-sign was not successful. Typically kernel updates can be handled seamlessly since the PCR4 value can be predicted from the PE hash of the new kernel and initrd. The PCRs will also be different when the system has had a firmware update from fwupd (usually measured into PCR0), or if the UEFI configuration is changed by the administrator (usually measured into PCR1 and PCR5). In both of these cases it is hard to predict what the resulting PCR values will be, so it is typically necessary to reboot into the recovery target to extend the PCRs with the new measurements and then update the PCR policy with the new values by running safeboot pcrs-sign . Some vendors publish the new PCR0 values, and it might be possible to predict it by evaluating the TPM event log, but it is not guaranteed. For a fleet of identical systems, however, it is usually possible to do this upgrade on one offline machine and then distribute the signed kernel along with the signed PCR policy to the other machines. This requires some additional work to make practical, since the TPM counters are not synchronized. How is safeboot's SIP related to macOS SIP? safeboot 's System Integrity Protection (SIP) is inspired by the read-only filesystems of macOS SIP . Like macOS, writing to the protected filesystems requires rebooting with a special kernel command line parameter (in this case tpm.mode=recovery ) to enable write access. Unlike macOS, safeboot SIP can not unseal the disk encryption keys automatically from the TPM since the boot mode is part of the PCR measurements, so knowledge of the disk recovery password is required. This prevents a local adversary who escalates to root from being able to disable SIP and reboot into a writable filesystem to try to gain persistence. safeboot's SIP is also inspired by the Android Verified Boot that protects Android's /system partition. Like Android, safeboot SIP provides cryptographic protection against an adversary who gains write access to the filesystem since entire filesystem is protected by the dmverity merkle tree of hashes. The root hash is signed by the system owner as part of exiting recovery mode, and this root hash is passed into the kernel on the command line. The kernel command line is part of the cryptographic chain of trust from the CPU boostrap through the Bootguard ACM, into the UEFI firmware, and all the way to the Linux kernel and initrd. This is potentially even stronger protection than macOS SIP since it provides protection even against an adversary with physical access, the root password and the disk recovery key. They can't sign the root hash without the hardware token, and if they change the signing keys in the firmare, then the TPM will no longer unseal the disk encryption key. They could re-seal the key with the new PCRs from their fake platform key, but the system would then fail both the TPM TOTP local attestation as well as the remote attestation when it tried to prove to an external system that it was in a trusted state. How do I write to the root filesystem? With SIP enabled it is not possible to modify the root filesystem. You must reboot into recovery mode with safeboot recovery-reboot and decrypt the disk with the recovery password. Once decrypted, you can run safeboot remount to unlock the raw device and remount it rw . After making modifications, it is necessary to sign the new root hashes with safeboot linux-sign . How do I switch to a new signing key? There is probably a way to sign a new PK with the old PK, but I haven't figured it out... Instead here are the steps: Put the UEFI SecureBoot firmware back in Setup Mode Boot into the recovery kernel safeboot remount to get write-access to the disk safeboot key-init or safeboot yubikey-init to build a new key. Answer \" y \" to overwrite the existing one in /etc/safeboot/cert.pem . safeboot uefi-sign-keys to upload it into the firmware safeboot recover-sign safeboot linux-sign , which should re-generate the dmverity hashes Reboot into the normal kernel safeboot luks-seal to measure the new PCRs and normal kernel into the TPM What happens if I lose the signing key? The best solution is to authenticate with the supervisor password to the UEFI Setup, re-enter SecureBoot setup mode and clear the key database, then boot into recovery mode and follow the instructions for switching to a new signing key. If you don't have the UEFI Supervisor password, well, then you're in trouble. Is it possible to reset the UEFI or BIOS password? On modern Thinkpads the UEFI password is in the EC, not in the SPI flash. Lenovo does a mainboard swap to reset it; you could find a EC bypass (Matrosov 2019) or perhaps a Bootguard bypass (Bosch & Hudson, 2019) to get into Setup in that case. Matrosov's 2019 BlackHat Talk is a deep dive into the Lenovo EC and why it is not as much of a protection boundary as some vendors think it is. Does it work on the Thinkpad 701c? Unfortunately the wonderful butterfly keyboard Thinkpad predates UEFI by a few years, so it does not have a very secure boot process. The X1 Carbon is a much nicer replacement in nearly every way, other than missing the amazing sliding keyboard mechanism. ??? Please file an issue! Or submit a pull-request!","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#what-is-the-threat-model","text":"safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. More details are in the threat model page .","title":"What is the threat model?"},{"location":"faq/#how-is-this-better-than-normal-uefi-secure-boot","text":"safeboot is not a replacement for UEFI SecureBoot - the two work together to improve the security of the system. SecureBoot ensures that the boot firmware is measured into the TPM and validates the signatures on the Linux kernel and initrd, and safeboot adds additional integrity protections beyond that. The default UEFI Secure Boot configuration is sufficient for Microsoft's needs since they are the only signing authority for their runtime, while Linux computer owners frequently want to compile their own kernel or runtime. The compromise solution developed by Linux distributions has Microsoft sign a \"shim\" bootloader that has its own key management. Since most distributions have their keys enrolled in the shim, systems that have Secure Boot enabled will boot the distribution's ISOs, which might not be desirable since it potentially gives an adversary runtime access to unencrypted parts of the system. A larger problem is that by default only the Linux kernel is signed, not the command line parameters or initrd. While the grub bootloader can enable a password to protect against casual changes to the kernel parameters, the grub.cfg configuration is not typically signed. This means that potentially a local attacker can modify it on disk to launch the kernel with init=/bin/sh to drop into a shell, or an attacker with root access can add trojan'ed binaries to the initrd to gain persistence. By replacing the Platform Key and removing grub , only Linux kernel and initrd images signed by the computer owner will boot. Far more details on how safeboot extends UEFI SecureBoot are on the threat model page .","title":"How is this better than normal UEFI Secure Boot?"},{"location":"faq/#does-safeboot-have-a-boothole","text":"BootHole ( CVE-2020-10713 ), is a vulnerability found and described by Eclypsium ) in grub 's configuration file parsing which allows arbitrary code execution in grub even when Secure Boot is enabled. Kelly Shortridge has a good writeup by at capsule8 that explains how this threat could be leveraged by an attacker and the difficulties in doing so in a general case, although an attacker with physical access is able to write to the internal disk and could launch this attack. Since these sorts of physical attacks are included in the safeboot threat model , it is worth considering. However, a system using safeboot is not vulnerable to CVE-2020-10713 since grub is not used at all and will not be run even if it is present on the disk. During the safeboot installation process, the system owner replaces the UEFI Platform Key with their own , which prevents the Microsoft signed shim used by grub from being loaded, and they then create efibootmgr entries for linux and recovery that are signed with their (hardware protected) key. Assuming there are not vulnerabilities in the system's UEFI firmware or CPU vendor's BootGuard (which may not be the best assumption...), the safeboot configuration should ensure that only signed kernel, initrd, and command lines will be booted by the system. This static chain of trust helps prevent attacks on grub like BootHole, or other ones that modify on-disk data, from being able to gain persistence or code execution. One caveat to the protection provided by the UEFI Secure Boot Platform Keys is that the UEFI NVRAM configuration data is stored in the SPI flash and is also subject to modifications by a physically proximate attacker with internal access to the hardware. However, if the attacker uses a flash programmer to change the Platform Keys in the flash, the TPM measurements of the Setup variable will be different and the TPM should refuse to unseal the disk encryption key since the PCR values will not match the sealed ones. The adversary might try to roll back to an vulnerable version of the kernel and the earlier signed PCRs, but the TPM will refuse to unseal since monotonic counter value will not match the signed one. An adversary might create a fake PIN entry screen to try to harvest the unsealing PIN or the recovery key, although in any of these cases, the TPM TOTP six-digit authenicator value will not be correct since the TPM will not unseal it with modified firmware. Additionally the system should fail remote attestation if it attempts to connect to a server that validates the TPM quote, improving platform resiliency even when attackers do gain persistence.","title":"Does safeboot have a BootHole?"},{"location":"faq/#how-does-safeboot-compare-to-coreboot","text":"coreboot is entirely free software and can provide far better control of the boot process, although it is not supported on as many modern platforms as UEFI SecureBoot and requires reprogramming the SPI flash on the device. If you have a machine that supports both coreboot and Bootguard, then you're probably better off running it instead. However, be prepared to spend quite a bit of quality time with your SPI flash programmer to get it working... Once coreboot or UEFI hand off to the Linux kernel, the TPM unsealing of the disk encryption key, the dmverity protections on the root filesystem and the lockdown patches work the same.","title":"How does safeboot compare to coreboot?"},{"location":"faq/#does-safeboot-work-with-amd-cpus","text":"It has only been tested on the Intel systems with Bootguard. The UEFI platform keys and the rest of the lock down should work with AMD, although AMD's hardware secured boot process hasn't been reviewed as extensively as Intel's ME and Bootguard. For an indepth analysis of the AMD Platform Support Processor (PSP) and SEV, Buhren, Eichner and Werling's 35c3 presentation is the most detailed look so far.","title":"Does safeboot work with AMD cpus?"},{"location":"faq/#does-safeboot-work-with-qubes-or-xen","text":"Qubes, a reasonably secure OS, uses the Xen hypervisor to separate device drivers and applications into separate virtual machines so that an exploit against an individual component doesn't necessarily compromise the entire machine. Unfortunately Xen's EFI support is not commonly used, and as a result running Qubes typically requires Legacy BIOS and turning off Secure Boot. Adding Secure Boot support to Xen is possible with some patches ( safeboot-issue #21 ), although it is a work in progress. There are other factors involved in configuring Qubes to use dm-verity and TPM sealed secrets that have not been addressed yet, as well as an open qubes-issue on distribution signing keys .","title":"Does safeboot work with Qubes or Xen?"},{"location":"faq/#what-causes-the-tpm-unsealing-to-fail","text":"The TPM will only unseal the disk encryption key if: The policy is signed by the UEFI platform key. The PCRs in $PCRS match the ones computed by the TPM, which typically include the firmware, UEFI setup variable, UEFI key database, and the PE hash of the kernel + initrd. The boot mode PCR in $BOOTMODE_PCR matches the sha256 hash of the safeboot.mode= kernel command line parameter and has not been extended post-boot. The TPM monotonic counter in $TPM_NV_VERSION matches the one in the policy. The user PIN matches the on used to seal the data. These requirements are violated by several different attacks, although they can also fail if a new kernel is installed with safeboot linux-sign and safeboot pcrs-sign was not successful. Typically kernel updates can be handled seamlessly since the PCR4 value can be predicted from the PE hash of the new kernel and initrd. The PCRs will also be different when the system has had a firmware update from fwupd (usually measured into PCR0), or if the UEFI configuration is changed by the administrator (usually measured into PCR1 and PCR5). In both of these cases it is hard to predict what the resulting PCR values will be, so it is typically necessary to reboot into the recovery target to extend the PCRs with the new measurements and then update the PCR policy with the new values by running safeboot pcrs-sign . Some vendors publish the new PCR0 values, and it might be possible to predict it by evaluating the TPM event log, but it is not guaranteed. For a fleet of identical systems, however, it is usually possible to do this upgrade on one offline machine and then distribute the signed kernel along with the signed PCR policy to the other machines. This requires some additional work to make practical, since the TPM counters are not synchronized.","title":"What causes the TPM unsealing to fail?"},{"location":"faq/#how-is-safeboots-sip-related-to-macos-sip","text":"safeboot 's System Integrity Protection (SIP) is inspired by the read-only filesystems of macOS SIP . Like macOS, writing to the protected filesystems requires rebooting with a special kernel command line parameter (in this case tpm.mode=recovery ) to enable write access. Unlike macOS, safeboot SIP can not unseal the disk encryption keys automatically from the TPM since the boot mode is part of the PCR measurements, so knowledge of the disk recovery password is required. This prevents a local adversary who escalates to root from being able to disable SIP and reboot into a writable filesystem to try to gain persistence. safeboot's SIP is also inspired by the Android Verified Boot that protects Android's /system partition. Like Android, safeboot SIP provides cryptographic protection against an adversary who gains write access to the filesystem since entire filesystem is protected by the dmverity merkle tree of hashes. The root hash is signed by the system owner as part of exiting recovery mode, and this root hash is passed into the kernel on the command line. The kernel command line is part of the cryptographic chain of trust from the CPU boostrap through the Bootguard ACM, into the UEFI firmware, and all the way to the Linux kernel and initrd. This is potentially even stronger protection than macOS SIP since it provides protection even against an adversary with physical access, the root password and the disk recovery key. They can't sign the root hash without the hardware token, and if they change the signing keys in the firmare, then the TPM will no longer unseal the disk encryption key. They could re-seal the key with the new PCRs from their fake platform key, but the system would then fail both the TPM TOTP local attestation as well as the remote attestation when it tried to prove to an external system that it was in a trusted state.","title":"How is safeboot's SIP related to macOS SIP?"},{"location":"faq/#how-do-i-write-to-the-root-filesystem","text":"With SIP enabled it is not possible to modify the root filesystem. You must reboot into recovery mode with safeboot recovery-reboot and decrypt the disk with the recovery password. Once decrypted, you can run safeboot remount to unlock the raw device and remount it rw . After making modifications, it is necessary to sign the new root hashes with safeboot linux-sign .","title":"How do I write to the root filesystem?"},{"location":"faq/#how-do-i-switch-to-a-new-signing-key","text":"There is probably a way to sign a new PK with the old PK, but I haven't figured it out... Instead here are the steps: Put the UEFI SecureBoot firmware back in Setup Mode Boot into the recovery kernel safeboot remount to get write-access to the disk safeboot key-init or safeboot yubikey-init to build a new key. Answer \" y \" to overwrite the existing one in /etc/safeboot/cert.pem . safeboot uefi-sign-keys to upload it into the firmware safeboot recover-sign safeboot linux-sign , which should re-generate the dmverity hashes Reboot into the normal kernel safeboot luks-seal to measure the new PCRs and normal kernel into the TPM","title":"How do I switch to a new signing key?"},{"location":"faq/#what-happens-if-i-lose-the-signing-key","text":"The best solution is to authenticate with the supervisor password to the UEFI Setup, re-enter SecureBoot setup mode and clear the key database, then boot into recovery mode and follow the instructions for switching to a new signing key. If you don't have the UEFI Supervisor password, well, then you're in trouble.","title":"What happens if I lose the signing key?"},{"location":"faq/#is-it-possible-to-reset-the-uefi-or-bios-password","text":"On modern Thinkpads the UEFI password is in the EC, not in the SPI flash. Lenovo does a mainboard swap to reset it; you could find a EC bypass (Matrosov 2019) or perhaps a Bootguard bypass (Bosch & Hudson, 2019) to get into Setup in that case. Matrosov's 2019 BlackHat Talk is a deep dive into the Lenovo EC and why it is not as much of a protection boundary as some vendors think it is.","title":"Is it possible to reset the UEFI or BIOS password?"},{"location":"faq/#does-it-work-on-the-thinkpad-701c","text":"Unfortunately the wonderful butterfly keyboard Thinkpad predates UEFI by a few years, so it does not have a very secure boot process. The X1 Carbon is a much nicer replacement in nearly every way, other than missing the amazing sliding keyboard mechanism.","title":"Does it work on the Thinkpad 701c?"},{"location":"faq/#_1","text":"Please file an issue! Or submit a pull-request!","title":"???"},{"location":"install/","text":"Danger Be careful! When following these instructions: it is possible to lock yourself out from your own machine if you forget some of the passwords. It is best to try this on a non-production system until you're certain that you understand how to use the recovery mode to fix bad kernel signatures or hashes. This guide was written for a Thinkpad X1 Carbon Gen 6 running Ubuntu 20.04. Unfortunately there has been churn in the tpm2 tools, so the Debian package does not work on 18.04. The outline for configuring safeboot requires some knowledge of the command line and familiarity with running commands as root with sudo . Releases for the the safeboot Debian package are in safeboot/releases . tl;dr Set UEFI SecureBoot setup mode Install Ubuntu 20.04, configure encrypted LVM partition Resizing '/' to 8GB during the install if you want to enable SIP wget https://github.com/osresearch/safeboot/releases/download/release-0.7/safeboot_0.7_amd64.deb sudo apt install safeboot_0.7_amd64.deb sudo update-initramfs -u sudo safeboot yubikey-init /CN=foo/ # or safeboot key-init if you don't have a token sudo safeboot uefi-sign-keys sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image. Login as usual. sudo safeboot luks-seal sudo update-initramfs -u sudo safeboot sip-init # if you want to enable SIP mode sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image again, with `/` mounted read-only. sudo safeboot linux-sign sudo reboot # Reboot one more time, now into dmverity protect Linux image... sudo safeboot luks-seal sudo reboot After this final reboot, the UEFI SecureBoot database will have the public signing keys, the UEFI boot manager will have entries for linux (which boots with a read-only dmverity protected root filesystem) and recovery (which boots with a root filesystem that can be remounted read-write), TPM should contain the disk encryption secret sealed to the linux boot mode, and now the disk should unlock automatically as long as no one tampers with the device. For more details as to how this all works, read on... Initial Setup This is done once when the system is being setup to use Safe Boot mode. Note that the hardware token and key signing portions can be done offline on a separate disconnected machine and then signed keys copied to the machine. UEFI firmware configuration The goal of these configuration changes are to remove several of the easy attacks such as booting from external disks, modifying kernel or initrd on disk, changing kernel command line parameters, as well as some of the more esoteric ones like DMA attacks against the Thunderbolt ports during the boot process. SecureBoot: Enter setup mode, erase keys Supervisor password (do not lose it! it is very difficult to bypass) Tamper switches: require supervisor password Thunderbolt 3: Disabled TPM: Enabled UEFI Secure Boot signing keys UEFI Secure Boot settings that the system will only run bootloaders that are signed by keys in the SPI flash. By default these keys are the OEM and Microsoft, and Microsoft will sign anyone else's key for $99, so it is important to replace these keys with ones under control of the computer owner. There is typically a signed \"shim\" that transfers control to the unsigned grub bootloader and kernel, which is problematic for security. A safer way to boot is to package the kernel, initrd and command line into a single EFI executable that is signed by the computer owner's key. This also reduces the attack surface by removing grub and the overly complicated config files, as well as speeds up the boot process a little bit. The owner key can be generated by openssl and stored offline, although using a hardware token like a yubikey greatly enhances the security of the system since even with root access an attacker can't gain persistence in the / or in the kernel. OpenSSL key generation First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot key-init /CN=foo/OU=bar/O=example.com/ The key-init subcommand will generate a password protected RSA2048 key and store it in /etc/safeboot/ along with the public certificate. The password provided here will be required to sign new kernel images and initrds, so don't lose it! TODO: What is the purpose of the x509 subject? Yubikey key generation Note Skip this if you have already initialized your hardware token and enrolled your keys in the UEFI SecureBoot database. Running it again will erase the keys from your hardware token. First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot yubikey-init /CN=foo/OU=bar/O=example.com/ The yubikey-init subcommand will do several steps: Use ykpersonalize to enable CCID mode. (TODO) Generate a new private key inside the Yubikey and export the public key Self-sign the public key to generate a new x509 certificate Reimport the certificate into the Yubikey so that UEFI variables and images can be signed with the hardware token. The public certificate is stored in /etc/safeboot/cert.pem . The private key never leaves the hardware token so it is much more difficult for an adversary to clone. Enrolling UEFI Platform Keys Replacing the UEFI Platform Key with the generated x509 cert requires that the UEFI SecureBoot firmware be put into \" Setup mode \". On the Thinkpads, select Reset to Setup Mode and Clear All Secure Boot Keys , then boot into Linux. To load the public key from /etc/safeboot/cert.pem into the UEFI secure boot key database: sudo safeboot uefi-sign-keys Once the key has been generated, the x509 certificate needs to be reformatted to be added to the UEFI Secure Boot platform key ( PK ), Key-Exchange Key ( KEK ) and as a key database entry ( db ). Each of these updates needs to be signed with the Platform Key; in the case of the PK it is self-signed. The safeboot uefi-sign-keys subcommand will: Generate the three EFI public key variables updates (UEFI platform key ( PK ), key-exchange key ( KEK ) and database ( db )) Sign the EFI variables with the Yubikey or OpenSSL key (will require a PIN authentication for each variable) Store the signed public certificates into the firmware. Danger Before you reboot! If you have not signed the kernel and initrd as described above, the system will not boot and you will have to disable UEFI Secure Boot to get back into the machine. Signed Linux recovery kernel Warning If you don't have a recovery entry in the EFI boot manager on the disk, you would need to have a USB drive signed with a key in the UEFI db to recover from errors. The next step is to use the Yubikey or OpenSSL key to sign and install a recovery kernel, which will be able to read/write mount the root filesystem, and does not have TPM sealing keys, so it will always require a recovery password to decrypt the disk. sudo safeboot recovery-sign This command will: Add UEFI boot menu item for recovery kernel Create a directory for it in the EFI System Partition (\"ESP\") Merge the vmlinux, initrd and command line into a single EFI executable Sign the merged EFI executable Typically you will not have to redo this command since the normal kernel will be hashed and signed during updates. The one exception is that once SIP mode is enabled you will have to resign the recovery image as well to ensure that it doesn't accidentally write to the / file system and corrupt the hashes. TPM Configuration The commands to seal the LUKS disk encryption key into the TPM, rebuild the initrd, sign the kernel/initrd, and update the expected PCR values are: sudo safeboot luks-seal sudo safeboot linux-sign sudo safeboot pcrs-sign You only need to run safeboot luks-seal the very first time; the sealed secret is included in the initrd image (stored in /etc/safeboot/sealed.secret ). When a new kernel or initrd is built, the platform key is used to sign both the kernel+initrd unified image, as well as the PCRs that go with it. The luks-seal subcommand will: Prompt for a decryption PIN, unless SEAL_PIN=0 in /etc/safeboot/local.conf Create a new disk encryption key with random data Add new key slot to disk with new key (will require the recovery password) Create a TPM policy that requires the PCRs defined in $PCRS to match a signed block Seal the disk encryption key with that policy and store it in /etc/safeboot/sealed.secret Add initramfs building hooks to unseal the secret Modify /etc/crypttab entry to call unlock script if necessary The Trusted Platform Module serves two purposes in securing the process: it helps validate that the firmware and boot configuration is unchanged, and it streamlines the boot process by providing the key for encrypted disks. On modern systems Boot Guard ensures that the initial boot block is measured into the TPM, so a local attacker shouldn't be able to modify the SPI flash contents to bypass the measurements, or to add their own keys to the UEFI key database. (Subject to various CVE's and TOCTOUs, etc) Note The TPM PCRs are somewhat fragile; they include hashes of the ROM images, the EFI executables that have been run along the boot path, etc. For example, entering the UEFI Setup menu will cause different measurements, so the TPM will not automatically unseal on the same boot that the user has entered the setup application. For normal operation only a direct boot into the unified kernel+initrd will automatically decrypt. When a new kernel is installed or the initrd needs to be updated, it is only necessary to sign the kernel and PCRs. The sealed LUKS key is no longer changed and the recovery password is not required. sudo safeboot linux-sign sudo safeboot pcrs-sign System Integrity Protection mode Note The \"SIP\" mode is optional and ensures that even an attacker with root priviledges can't make persistent changes to the contents of the root filesystem. It uses the same dmverity as Android's verified boot mode . The root of the dm-verity Merkle-tree is passed to the kernel as part of the signed command line, ensuring that an attacker can't change anything on the filesystem without access to the signing key. Any modifications to the filesystem will be detected when the modified blocks are read, allowing the system to enter recovery mode to protect its data. RO and RW Partition setup Resizing the root filesystem is necessary so that it can be made read-only, as well as to make space for /home and /var as separate writable mounts, and also so that dmverity hash computation doesn't take forever. The partition resize to prepare the system for SIP mode must be done from the recovery shell, since the root file system can't be mounted while it is being modified. Warning There is a high risk of data loss if these commands are mistyped or if the resize2fs fails. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. In the recovery shell, run these commands to decrypt the root disk, make sure it is clena, resize the filesystem, and then resize the logical volume. No need for sudo , since the recovery shell is always root. crypt_unlock fsck -f /dev/vgubuntu/root resize2fs /dev/vgubuntu/root 12G lvresize --size 12G /dev/vgubuntu/root Once that is done you can continue the boot into the system in recovery mode and configure SIP. The sip-init command will setup the /var and /home filesystems, add them to /etc/fstab , relocate /tmp , build the initial dmverity hashes, and add the signed linux to the efi boot menu: Warning There is a high risk of data loss if the sip-init command is unable to complete. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. sudo safeboot sip-init Hashing and signing the RO root filesystem When exiting recovery mode it is necessary to rehash the root filesystem and sign the kernel command line: sudo safeboot linux-sign The linux-sign command will: unmount / and remount it ro fsck / to ensure that it is clean run veritysetup format to compute the Merkle-tree for /dev/vgubuntu/root write the hashes to /dev/vgubuntu/hashes merge the linux kernel, initrd, and a command line with the dmverity root hash into an EFI executable sign this executable and install it as the default entry in the EFI boot manager Because this might change the EFI boot manager, it is necessary to reboot into the SIP mode and then re-seal the TPM key with safeboot luks-seal as documented above. TODO: Detect changes and notify the use rather than just EIO . Updates Nothing ever stays static, so it is important to consider the steps for updating the system. Frequently the root file system and kernel will be updated together, so these steps can be batched. Hopefully TPM re-sealing doesn't have to happen as often, since it requires access to the disk encryption recovery key. Root filesystem updates To re-enter recovery mode, remount the / filesystem read/write and re-hash the filesystem for normal mode: sudo safeboot recovery-reboot # enter the disk recovery password and login sudo safeboot remount # do stuff to / like apt-get ... sudo safeboot linux-sign sudo safeboot pcrs-sign reboot The recovery-reboot and remount subcommands: Set the UEFI Boot Manager BootNext to recovery Reboot the machine Require a manual disk decryption recovery code Runs blockdev --setrw to re-enable writes to the root device Runs mount -o rw,remount / to re-enable writes to the root filesystem After updating the file system with tools like apt install ... , the linux-sign subcommand will: Run mount -o ro,remount / to make the root filesystem readonly fsck / to ensure that it is clean veritysetup format to compute the merkle-tree Use the Yubikey or OpenSSL key to sign the merkle-tree root hash Reboot to the new read-only runtime The pcrs-sign subcommand will: Compute the expected PCR4 value for the new Linux kernel + initrd Sign it along with the other PCR values Store the signature on the PCR in a UEFI NVRAM variable If you are maintaining a fleet of machines, these could be done offline and the block image pushed to the system for installation. Note that while the PCR4 value can be predicted, the other PCRs might be machine specific. More research is necessary for proper fleet management. Kernel and initramfs update Re-generate /boot/initrd and /boot/vmlinuz Merge the kernel, initrd and command line into a single EFI executable Use the hardware token to sign that executable Copy the signed image to the EFI boot partition These could be done offline and the block image pushed to the system for installation UEFI firmware update If there are any updates to the UEFI firmware, such as changing the Setup variable, then the TPM sealed keys will no longer be accessible. From the recovery mode should be possible to sign the new PCRs (currently it requires more facilities than are available in the recovery initrd), or the recovery key can be used to mount the disk and re-seal the drive.","title":"Installation"},{"location":"install/#tldr","text":"Set UEFI SecureBoot setup mode Install Ubuntu 20.04, configure encrypted LVM partition Resizing '/' to 8GB during the install if you want to enable SIP wget https://github.com/osresearch/safeboot/releases/download/release-0.7/safeboot_0.7_amd64.deb sudo apt install safeboot_0.7_amd64.deb sudo update-initramfs -u sudo safeboot yubikey-init /CN=foo/ # or safeboot key-init if you don't have a token sudo safeboot uefi-sign-keys sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image. Login as usual. sudo safeboot luks-seal sudo update-initramfs -u sudo safeboot sip-init # if you want to enable SIP mode sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image again, with `/` mounted read-only. sudo safeboot linux-sign sudo reboot # Reboot one more time, now into dmverity protect Linux image... sudo safeboot luks-seal sudo reboot After this final reboot, the UEFI SecureBoot database will have the public signing keys, the UEFI boot manager will have entries for linux (which boots with a read-only dmverity protected root filesystem) and recovery (which boots with a root filesystem that can be remounted read-write), TPM should contain the disk encryption secret sealed to the linux boot mode, and now the disk should unlock automatically as long as no one tampers with the device. For more details as to how this all works, read on...","title":"tl;dr"},{"location":"install/#initial-setup","text":"This is done once when the system is being setup to use Safe Boot mode. Note that the hardware token and key signing portions can be done offline on a separate disconnected machine and then signed keys copied to the machine.","title":"Initial Setup"},{"location":"install/#uefi-firmware-configuration","text":"The goal of these configuration changes are to remove several of the easy attacks such as booting from external disks, modifying kernel or initrd on disk, changing kernel command line parameters, as well as some of the more esoteric ones like DMA attacks against the Thunderbolt ports during the boot process. SecureBoot: Enter setup mode, erase keys Supervisor password (do not lose it! it is very difficult to bypass) Tamper switches: require supervisor password Thunderbolt 3: Disabled TPM: Enabled","title":"UEFI firmware configuration"},{"location":"install/#uefi-secure-boot-signing-keys","text":"UEFI Secure Boot settings that the system will only run bootloaders that are signed by keys in the SPI flash. By default these keys are the OEM and Microsoft, and Microsoft will sign anyone else's key for $99, so it is important to replace these keys with ones under control of the computer owner. There is typically a signed \"shim\" that transfers control to the unsigned grub bootloader and kernel, which is problematic for security. A safer way to boot is to package the kernel, initrd and command line into a single EFI executable that is signed by the computer owner's key. This also reduces the attack surface by removing grub and the overly complicated config files, as well as speeds up the boot process a little bit. The owner key can be generated by openssl and stored offline, although using a hardware token like a yubikey greatly enhances the security of the system since even with root access an attacker can't gain persistence in the / or in the kernel.","title":"UEFI Secure Boot signing keys"},{"location":"install/#openssl-key-generation","text":"First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot key-init /CN=foo/OU=bar/O=example.com/ The key-init subcommand will generate a password protected RSA2048 key and store it in /etc/safeboot/ along with the public certificate. The password provided here will be required to sign new kernel images and initrds, so don't lose it! TODO: What is the purpose of the x509 subject?","title":"OpenSSL key generation"},{"location":"install/#yubikey-key-generation","text":"Note Skip this if you have already initialized your hardware token and enrolled your keys in the UEFI SecureBoot database. Running it again will erase the keys from your hardware token. First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot yubikey-init /CN=foo/OU=bar/O=example.com/ The yubikey-init subcommand will do several steps: Use ykpersonalize to enable CCID mode. (TODO) Generate a new private key inside the Yubikey and export the public key Self-sign the public key to generate a new x509 certificate Reimport the certificate into the Yubikey so that UEFI variables and images can be signed with the hardware token. The public certificate is stored in /etc/safeboot/cert.pem . The private key never leaves the hardware token so it is much more difficult for an adversary to clone.","title":"Yubikey key generation"},{"location":"install/#enrolling-uefi-platform-keys","text":"Replacing the UEFI Platform Key with the generated x509 cert requires that the UEFI SecureBoot firmware be put into \" Setup mode \". On the Thinkpads, select Reset to Setup Mode and Clear All Secure Boot Keys , then boot into Linux. To load the public key from /etc/safeboot/cert.pem into the UEFI secure boot key database: sudo safeboot uefi-sign-keys Once the key has been generated, the x509 certificate needs to be reformatted to be added to the UEFI Secure Boot platform key ( PK ), Key-Exchange Key ( KEK ) and as a key database entry ( db ). Each of these updates needs to be signed with the Platform Key; in the case of the PK it is self-signed. The safeboot uefi-sign-keys subcommand will: Generate the three EFI public key variables updates (UEFI platform key ( PK ), key-exchange key ( KEK ) and database ( db )) Sign the EFI variables with the Yubikey or OpenSSL key (will require a PIN authentication for each variable) Store the signed public certificates into the firmware. Danger Before you reboot! If you have not signed the kernel and initrd as described above, the system will not boot and you will have to disable UEFI Secure Boot to get back into the machine.","title":"Enrolling UEFI Platform Keys"},{"location":"install/#signed-linux-recovery-kernel","text":"Warning If you don't have a recovery entry in the EFI boot manager on the disk, you would need to have a USB drive signed with a key in the UEFI db to recover from errors. The next step is to use the Yubikey or OpenSSL key to sign and install a recovery kernel, which will be able to read/write mount the root filesystem, and does not have TPM sealing keys, so it will always require a recovery password to decrypt the disk. sudo safeboot recovery-sign This command will: Add UEFI boot menu item for recovery kernel Create a directory for it in the EFI System Partition (\"ESP\") Merge the vmlinux, initrd and command line into a single EFI executable Sign the merged EFI executable Typically you will not have to redo this command since the normal kernel will be hashed and signed during updates. The one exception is that once SIP mode is enabled you will have to resign the recovery image as well to ensure that it doesn't accidentally write to the / file system and corrupt the hashes.","title":"Signed Linux recovery kernel"},{"location":"install/#tpm-configuration","text":"The commands to seal the LUKS disk encryption key into the TPM, rebuild the initrd, sign the kernel/initrd, and update the expected PCR values are: sudo safeboot luks-seal sudo safeboot linux-sign sudo safeboot pcrs-sign You only need to run safeboot luks-seal the very first time; the sealed secret is included in the initrd image (stored in /etc/safeboot/sealed.secret ). When a new kernel or initrd is built, the platform key is used to sign both the kernel+initrd unified image, as well as the PCRs that go with it. The luks-seal subcommand will: Prompt for a decryption PIN, unless SEAL_PIN=0 in /etc/safeboot/local.conf Create a new disk encryption key with random data Add new key slot to disk with new key (will require the recovery password) Create a TPM policy that requires the PCRs defined in $PCRS to match a signed block Seal the disk encryption key with that policy and store it in /etc/safeboot/sealed.secret Add initramfs building hooks to unseal the secret Modify /etc/crypttab entry to call unlock script if necessary The Trusted Platform Module serves two purposes in securing the process: it helps validate that the firmware and boot configuration is unchanged, and it streamlines the boot process by providing the key for encrypted disks. On modern systems Boot Guard ensures that the initial boot block is measured into the TPM, so a local attacker shouldn't be able to modify the SPI flash contents to bypass the measurements, or to add their own keys to the UEFI key database. (Subject to various CVE's and TOCTOUs, etc) Note The TPM PCRs are somewhat fragile; they include hashes of the ROM images, the EFI executables that have been run along the boot path, etc. For example, entering the UEFI Setup menu will cause different measurements, so the TPM will not automatically unseal on the same boot that the user has entered the setup application. For normal operation only a direct boot into the unified kernel+initrd will automatically decrypt. When a new kernel is installed or the initrd needs to be updated, it is only necessary to sign the kernel and PCRs. The sealed LUKS key is no longer changed and the recovery password is not required. sudo safeboot linux-sign sudo safeboot pcrs-sign","title":"TPM Configuration"},{"location":"install/#system-integrity-protection-mode","text":"Note The \"SIP\" mode is optional and ensures that even an attacker with root priviledges can't make persistent changes to the contents of the root filesystem. It uses the same dmverity as Android's verified boot mode . The root of the dm-verity Merkle-tree is passed to the kernel as part of the signed command line, ensuring that an attacker can't change anything on the filesystem without access to the signing key. Any modifications to the filesystem will be detected when the modified blocks are read, allowing the system to enter recovery mode to protect its data.","title":"System Integrity Protection mode"},{"location":"install/#ro-and-rw-partition-setup","text":"Resizing the root filesystem is necessary so that it can be made read-only, as well as to make space for /home and /var as separate writable mounts, and also so that dmverity hash computation doesn't take forever. The partition resize to prepare the system for SIP mode must be done from the recovery shell, since the root file system can't be mounted while it is being modified. Warning There is a high risk of data loss if these commands are mistyped or if the resize2fs fails. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. In the recovery shell, run these commands to decrypt the root disk, make sure it is clena, resize the filesystem, and then resize the logical volume. No need for sudo , since the recovery shell is always root. crypt_unlock fsck -f /dev/vgubuntu/root resize2fs /dev/vgubuntu/root 12G lvresize --size 12G /dev/vgubuntu/root Once that is done you can continue the boot into the system in recovery mode and configure SIP. The sip-init command will setup the /var and /home filesystems, add them to /etc/fstab , relocate /tmp , build the initial dmverity hashes, and add the signed linux to the efi boot menu: Warning There is a high risk of data loss if the sip-init command is unable to complete. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. sudo safeboot sip-init","title":"RO and RW Partition setup"},{"location":"install/#hashing-and-signing-the-ro-root-filesystem","text":"When exiting recovery mode it is necessary to rehash the root filesystem and sign the kernel command line: sudo safeboot linux-sign The linux-sign command will: unmount / and remount it ro fsck / to ensure that it is clean run veritysetup format to compute the Merkle-tree for /dev/vgubuntu/root write the hashes to /dev/vgubuntu/hashes merge the linux kernel, initrd, and a command line with the dmverity root hash into an EFI executable sign this executable and install it as the default entry in the EFI boot manager Because this might change the EFI boot manager, it is necessary to reboot into the SIP mode and then re-seal the TPM key with safeboot luks-seal as documented above. TODO: Detect changes and notify the use rather than just EIO .","title":"Hashing and signing the RO root filesystem"},{"location":"install/#updates","text":"Nothing ever stays static, so it is important to consider the steps for updating the system. Frequently the root file system and kernel will be updated together, so these steps can be batched. Hopefully TPM re-sealing doesn't have to happen as often, since it requires access to the disk encryption recovery key.","title":"Updates"},{"location":"install/#root-filesystem-updates","text":"To re-enter recovery mode, remount the / filesystem read/write and re-hash the filesystem for normal mode: sudo safeboot recovery-reboot # enter the disk recovery password and login sudo safeboot remount # do stuff to / like apt-get ... sudo safeboot linux-sign sudo safeboot pcrs-sign reboot The recovery-reboot and remount subcommands: Set the UEFI Boot Manager BootNext to recovery Reboot the machine Require a manual disk decryption recovery code Runs blockdev --setrw to re-enable writes to the root device Runs mount -o rw,remount / to re-enable writes to the root filesystem After updating the file system with tools like apt install ... , the linux-sign subcommand will: Run mount -o ro,remount / to make the root filesystem readonly fsck / to ensure that it is clean veritysetup format to compute the merkle-tree Use the Yubikey or OpenSSL key to sign the merkle-tree root hash Reboot to the new read-only runtime The pcrs-sign subcommand will: Compute the expected PCR4 value for the new Linux kernel + initrd Sign it along with the other PCR values Store the signature on the PCR in a UEFI NVRAM variable If you are maintaining a fleet of machines, these could be done offline and the block image pushed to the system for installation. Note that while the PCR4 value can be predicted, the other PCRs might be machine specific. More research is necessary for proper fleet management.","title":"Root filesystem updates"},{"location":"install/#kernel-and-initramfs-update","text":"Re-generate /boot/initrd and /boot/vmlinuz Merge the kernel, initrd and command line into a single EFI executable Use the hardware token to sign that executable Copy the signed image to the EFI boot partition These could be done offline and the block image pushed to the system for installation","title":"Kernel and initramfs update"},{"location":"install/#uefi-firmware-update","text":"If there are any updates to the UEFI firmware, such as changing the Setup variable, then the TPM sealed keys will no longer be accessible. From the recovery mode should be possible to sign the new PCRs (currently it requires more facilities than are available in the recovery initrd), or the recovery key can be used to mount the disk and re-seal the drive.","title":"UEFI firmware update"},{"location":"protocol/","text":"Safeboot.dev Enrollment, Attestation, and Proof-of-Possession Protocols This document describes the Safeboot.dev enrollment and attestation protocols. These protocols are based on the Trusted Computing Group's (TCG) Trusted Platform Module (TPM), using a discrete TPM or a firmware TPM to secure enrollment and delivery of secrets to enrolled devices. The use of a TPM helps provide decent assurance of device state at certain times, provides us with a way to bootstrap trust. The Safeboot.dev enrollment protocol creates long-term state for an enrolled device, including secrets/credentials needed by the device. The Safeboot.dev attestation protocol conveys enrolled state to devices that demonstrate being in good state. NOTE: The protocol is described as it will soon be. Specifically, the use of digital signatures for authentication of long-term enrolled assets is not yet integrated. See Pull Request #140 . Goals protocol specification sufficient for security review Background The security of the Safeboot.dev protocols depends critically on the use of TPMs. Reviewers must be familiar with some of the relevant TPM concepts listed below. Some useful links: Introduction to TPMs Device Enrollment What Attestation Is Critical Background It is essential that readers understand: TPM2_MakeCredential() TPM2_ActivateCredential() Cryptographic object naming Readers should also have a passing understanding of how authorization works in a TPM 2.0 as well, especially when a TPM requires a caller to execute some authorization policy, and which policy. Readers must be familiar with the TPM2_MakeCredential() / TPM2_ActivateCredential() constructs. We describe these somewhat here. TPM2_MakeCredential() is an operation that amounts to encryption of a small secret to a public key, but with a binding to the cryptographic name of an \"activation object\". TPM2_ActivateCredential() decrypts such ciphertexts provided that: the caller has access to the private key to whose public key TPM2_MakeCredential() encrypted the payload, and that the caller has access to the \"activation object\" named by the caller of TPM2_MakeCredential() . As the cryptographic name of an object binds to it any authorization policies associated with use of that object, the caller of TPM2_ActivateCredential() must meet that policy. This means that the caller of TPM2_MakeCredential() can require specific authorization and other attributes -via the activation object's name- that the caller of TPM2_ActivateCredential() must satisfy. For example, a device that will call TPM2_ActivateCredential() can supply the activation object's public key to the peer that will call TPM2_MakeCredential() , then that peer can combine the activation object's public key with the attributes expected of the activation object to cause the protocol to succeed IFF the possessor of the activation object created it with those same attributes. NOTE: The activation object's private key is not itself used for any cryptographic operations in TPM2_ActivateCredential() . Only the activation object's cryptographic name and its attributes are used. NOTE: The TPM2_MakeCredential() function can be implemented entirely in software, as it requires no privileged access to any objects stored in any TPMs. NOTE: It is essential to the security of the Safeboot.dev protocols that enrolled devices' TPMs be legitimate TPMs or virtual TPMs run by trusted agents. This is due to the protocol depending on the TPM to enforce authorization policies for certain functions that an untrusted implementation could forgo. Other TPM Background Some less critical TPM background: Hash extension Platform Configuration Registers (PCRs) Root of Trust Measurement (RTM) Authorization Key hierarchies Terminology We will use a lot of terminology from the TCG universe. In particular we will speak of: credential Depending on the context, \"credential\" will refer either to: a) a secret or private key and possibly some metadata which can be used to access some remote resources -- for example, a PKIX certificate and private key --, b) a small secret key -typically an AES key- encrypted with TPM2_MakeCredential() . credential activation The successful use of TPM2_ActivateCredential() to recover a small secret. activation object A TPM entity whose cryptographic name is used in making a \"credential\" with TPM2_MakeCredential() , and a handle and authorization session to which will be provided by the caller of TPM2_ActivateCredential() to recover the credential. Use Cases: Secure Boot, Device Credential Provisioning The Safeboot.dev enrollment and attestation protocols support two use cases: secure boot device credential provisioning These two uses differ only in whether the enrolled device is expected to perform UEFI secure boot. In all cases Safeboot.dev enrollment is about creating sensitive files/blobs/assets that are stored encrypted to the device's TPM and to escrow agents. In all cases Safeboot.dev attestation is about delivering enrolled assets to devices in trusted state. Use Cases: Secure Boot This use-case involves the device encrypting local storage with a secret long-term key obtained at boot time via the attestation protocol. Use Cases: Device Credential Provisioning This use-case involves delivering to the device credentials such as: private keys and PKIX certificates for their public keys (for, e.g., TLS and/or IPsec) Kerberos keys (\"keytabs\") OpenSSH host keys and certificates service account tokens of various kinds Use Cases: Secure Boot and Device Credential Provisioning Naturally, both of these use cases can be combined. In fact, they are the same use case, differing only in the nature of the material delivered to the client. Use Cases Currently Out of Scope Other attestation protocols are meant to be used not just at boot time but very often, and not so much for delivering device credentials to the client device as for ascertaining the continued trusted state of the client device. Devices that fail to attest successfully and often enough might, e.g., be locked out of the network. Such protocols may depend on having some dynamic state on the server side. For example, keeping track of the last time that a client attested, its TPM's resetCount (to make sure it never goes backward, and to detect reboots), etc. Nothing about Safeboot.dev's protocols precludes the use of other attestation protocols for purposes other than the use cases listed above. Nothing about Safeboot.dev's current protocols precludes the addition to Safeboot.dev of functionality similar to those other projects' attestation protocols'. Threat Model The primary threats that the Safeboot.dev enrollment and attestation protocols seek to protect against are: theft of devices and/or their local storage passive attacks on the attestation protocol active attacks on the attestation protocol any attacks on the enrollment protocol Assumptions We assume that: enrollment and attestation servers are physically secure access to enrollment and attestation servers is secured the credentials held by enrollment and attestation servers are secure the enrollment database and any associated servers are secure read access to the enrollment database can be secured enrollment database protocols are secure Threat Models Out of Scope The following threats are out of scope for this document: any attacks on the attestation server (other than via attacks on the attestation protocol) any attacks on the enrollment database any attacks on the enrollment server (other than via attacks on the enrollment protocol) post-attestation attacks on devices Architecture The Safeboot.dev architecture consists of two separate protocols: one for enrollment, and one for attestation. The Safeboot.dev attestation protocol operates using state created at enrollment time. Enrollment is the act of creating state binding a device's TPM and a name for that device, as well as creating any secrets and/or metadata that that device may repeatedly need in the environment it will be used in. The separation of enrollment and attestation is motivated by: privilege separation considerations We'd like to isolate any issuer credentials to as few systems as possible, while allowing the attestation service to be widely replicated. Because enrollment is a low-frequency event, while attestation a high-frequency event, we can have fewer enrollment servers and more attestation servers. Then we can isolate issuer credentials by placing them only on enrollment servers. database replication and write concurrency considerations Having state created and manipulated only at enrollment servers allows us to replicate the enrollment database to attestation servers as a read-only database. Together with the low frequency of enrollment events this frees us from having to address concurrent database updates at this time, at the cost of having primary/secondary enrollment server roles. Any future evolution of Safeboot.dev towards more dynamic attestation state may well use separate databases for enrolled assets and attestation state. Our interest in privilege separation does not preclude such an evolution, as the separation between one database type and the other would tend to fulfill that interest. Enrollment Protocol The enrollment protocol cosists of an HTTP API called over HTTPS: /v1/add -- POST here to enroll, as described above /v1/find -- GET here to query the enrolled device database by hostname /v1/query -- GET here to query the enrolled device database by EKhash /v1/delete -- POST here to delete an enrolled device's database entry All of these end-points are 1 round trip, naturally (except where HTTP authentication methods used require more round trips). The /v1/add and /v1/delete end-points expect an HTML form to be posted. The /v1/find end-point expects a single query parameter to be given: hostname , with a hostname prefix. The /v1/query end-point expects a single query parameter to be given: ekpubhash , with a hash of EKpub prefix. The /v1/add end-point takes two inputs from the client, delivered as an HTML form over an HTTPS POST: hostname -- the desired device name ekpub -- the device's TPM's endorsement public key ( EKpub ), either in TPM2B_PUBLIC or PEM formats (either as a public key or as a certificate) An EK certificate is preferred, as that can be validated by checking that its issuer chains to a trusted TPM vendor root certification authority (CA). In environments such as the Google compute cloud's Shielded VMs, there may not be an EK certificate available, but instead an API may be available to validate an EKpub . User authentication and authorization MAY be required if only certain users should be allowed to enroll devices. The choice of HTTP authentication method is not specified here (options include Negotiate, Bearer, OIDC, SCRAM, etc.). The enrollment server ensures that the creation of the binding of device name and EKpub is made atomically. NOTE: In a putative future where multiple enrollment servers can concurrently create these bindings, we may dispense with atomic bindings; instead a conflict resolution mechanism MAY be used to resolve conflicts. The enrollment server will also provision the device with any number of secrets and metadata of various kinds that will be transported to the device during attestation. These are stored encrypted at rest (more on this below). No request or response headers are used. No universal resource identifier (URI) query-parts are used. The URI local-part need only denote that it is the enrollment end-point. We are using the following URI local-parts: Types of Secrets and Metadata Provisioned Various types of long-term secrets and metadata can be provisioned to an enrolled device: configuration early boot scripts symmetric keys (or passphrase) for local storage encryption private keys and PKIX certificates for them (client, server) for TLS, IPsec, etc. Kerberos keys (\"keytab\") service account tokens IPsec keys for manually keyed SAs etc. IMPLEMENTATION NOTE: These are configurable as genprog s for the sbin/attest-enroll program. See its usage message. Data-at-Rest Encryption All these secrets created by the /v1/add end-point are encrypted to the device's TPM's EKpub and separately also encrypted to the public keys of configured escrow agents for, e.g., break-glass recovery. For every secret asset the server generates a random AES-256 key. The plaintext of the secret to be encrypted is then encrypted using the AES-256 key in an authenticated encryption cipher mode. See Appendix-A . The AES-256 key is then encrypted to the enrolled device's EKpub and to any configured escrow agents' public keys. Encryption to Escrow Agents Encryption to escrow agents is done using raw RSA public keys. Encryption to Device EKpub All these secrets are encrypted to the device's TPM's EKpub , each with an optional, configurable TPM authorization policy. Two mechanisms can be used for encryption to a device's TPM: the \"WK\" and \"TK\" mechanisms. A TPM authorization policy is a TPM 2.0 enhanced authorization (EA) policy, and will be enforced by the device's TPM when called to decrypt one of these secrets. The default policy for the rootfs key (a symmetric key for local storage encryption) is that the platform configuration register (PCR) #11 must have the initial value (all zeros), with the expecation that the attestation client will immediately extend PCR #11 (with no particular value -- just some value) so that the TPM will not again decrypt the same ciphertext unless the device reboots. Policies are configurable for each secret type. NOTE: We could use well-known PCR#11 extension values for the purpose of creating specific time windows during the boot process during which different secrets could be decrypted. NOTE: Both, the WK and TK methods offer equivalent functionality. We support both mainly for historical reasons. The WK method is simpler, but the TK method was implemented first. Encryption to TPM EKpub : WK Method NOTE: Readers are expected to understand the TPM2_MakeCredential() and TPM2_ActivateCredential() functions. See the Critical Background section . A well-known public key ( WK ) is loaded into a software TPM using TPM2_LoadExternal() with the desired policy's policyDigest . TPM2_MakeCredential() is called with these input parameters: the WKpub (the loaded WK) as the objectName input parameter, the device's EKpub as the handle input parameter, and the AES-256 symmetric key as the credential input parameter (the plaintext). The outputs of TPM2_MakeCredential() ( credentialBlob and secret ) make up the ciphertext of the AES-256 key encrypted to the TPM's EKpub . The details of what TPM2_MakeCredential() does are described in the TCG TPM 2.0 Library part 1: Architecture, section 24 (Credential Protection) . Decryption is done by calling TPM2_ActivateCredential() on the TPM that has the EK corresponding to the EKpub . Critically, the TPM will refuse to \"activate\" the credential (i.e., decrypt the ciphertext) unless the caller has satisfied the WK's authPolicy (if set). To decrypt, access to the TPM identified by the EKpub is needed. The process is as follows: call TPM2_LoadExternal() the well-known key, with the desired authPolicy , if any call TPM2_StartAuthSession() to create a policy session for the EK call TPM2_PolicySecret() to obtain access to the EK call TPM2_StartAuthSession() to create a policy session for the WK (if the WK had a policyDigest set) call the policy commands on the WK session handle to satisfy its policy (if one was set) call TPM2_ActivateCredential() with the loaded WK as the activateHandle and its corresponding policy session, the EK as the keyHandle and its corresponding policy session, and the ciphertext ( credentialBlob and secret ) as input parameters The WK 's authorization policy, if set, is enforced by TPM2_ActivateCredential() . Then, once the AES-256 key is decrypted, the confounded AES-256-CBC-HMAC-SHA256 ciphertext is decrypted as described above. Encryption to TPM EKpub : TK Method create an RSA key-pair in software encrypt the AES-256 key to the RSA public key using OEAP with any software use a software TPM to encrypt the RSA private key from (1) to the EKpub of the target TPM using TPM2_Duplicate() , setting the desired policy's policyDigest as the intended authPolicy of the RSA key as it will be when loaded by the target TPM the ciphertext then consists of a) the ciphertext from encryption to the RSA public key, b) the outputs of TPM2_Duplicate() To decrypt, access to the TPM identified by the EKpub is needed. The process is as follows: call TPM2_StartAuthSession() to create a policy session for the EK call TPM2_PolicySecret() to obtain access to the EK call TPM2_Import() and TPM2_Load() to import and load the output of TPM2_Duplicate() call TPM2_StartAuthSession() to create a policy session for the TK (if the TK had a policyDigest set) call the policy commands on the WK session handle to satisfy its policy (if one was set) call TPM2_RSA_Decrypt() to decrypt the AES-256 key with the imported TK The TK 's authorization policy, if set, is enforced by TPM2_RSA_Decrypt() . Then, once the AES-256 key is decrypted, the confounded AES-256-CBC-HMAC-SHA256 ciphertext is decrypted as described above. Break-Glass Recovery Break-glass recovery consists of: replacing a device's TPM or the device itself (including its TPM), decrypting the secret AES-256 keys stored in the enrollment DB using an escrow agent, encrypting those to the new TPM's EKpub , and replacing the corresponding ciphertexts in the enrolled device's entry in the enrollment DB. Any break-glass recovery operations must be performed only by authorized users. Attestation Protocol The Safeboot.dev attestation protocol is a single round trip protocol that allows a device to obtain its enrolled assets from the attestation server in exchange for successfully attesting to the device's state. State that can be attested: recency -- via a timestamp that the caller has access to the EK the values of PCRs, which reflect the firmware ROMs and operating system loaded the TPM's resetCount (count of reboots) anything that can be required by a TPM policy To attest its state, a client device first generates an \"attestation key\" ( AK ) -- an asymmetric signing keypair. This object must have the stClear attribute set, which means that the TPM will refuse to reload or re-create this AK if the TPM is reset (which happens when the host device reboots). It must also have the fixedTPM , fixedParent , and sign attributes set. Then the client creates a \"quote\" of all the PCRs, signed with the AK . See TPM2_Quote() . The attestation protocol consists of an HTTP POST (HTTPS not required) with: /v1/attest as the end-point no particular request headers no URI query-parameters no HTTP authentication needed the request body consisting of an uncompressed tar file containing the following items: ek.crt -- the EKcert , that is, the PKIX certificate for the TPM's endorsment key (EK) as provisioned by the TPM's vendor (this is optional, present only if the TPM has an EKcert ) ek.pub -- the EKpub in TPM2B_PUBLIC format ak.pub -- the TPM2B_PUBLIC representation of the AK ak.ctx -- the AK object, saved to help make it easier for the client to keep state quote.out , quote.sig , and quote.pcr -- the outputs of TPM2_Quote() using the AK nonce -- not actually a nonce but a timestamp as seconds since the Unix epoch eventlog -- if possible, this is the TPM PCR eventlog kept by the UEFI BIOS ima -- if possible, this is the Linux IMA log The attestation server then: looks up the device's enrollment DB entry by the given EKpub examines the ak.pub to ensure that it has the desired attributes (specifically: sign fixedTPM fixedParent stClear and recomputes the AK 's cryptographic name for later use as the activation object name request parameter of TPM2_MakeCredential() verifies that the eventlog matches the PCRs verifies that the digests that appear in the eventlog are acceptable, or that the PCRs match \"golden PCRs\" examines the nonce to verify that it is a recent timestamp If all the validation steps succeed, then the attestation server: generates an ephemeral AES-256 session key, constructs a tarball of the device's long-term enrolled assets from the device's enrollment database entry, encrypts that tarball in the session key, encrypts the session key to the device's TPM's EKpub using TPM2_MakeCredential() with the AKpub 's cryptographic name as the objectName and the EKpub as the handle In the successful case, then, the response body is a tarball consisting of: credential.bin -- a file containing the credentialBlob and secret output parameters of the TPM2_MakeCredential() call cipher.bin -- the ciphertext of a tarball of the device's enrollment DB entry, encrypted with the AES-256 session key using confounded AES-256-CBC-HMAC-SHA-256 as described above. ak.ctx (as provided by the client, sent back) The client can decrypt and recover the AES-256 session key IFF it has a TPM with the corresponding EK and AK loaded. Having recovered the AES-256 session key, the client can decrypt the tarball of the client's long-term secrets and metadata, where the secrets are encrypted to the client's TPM using the WK or TK methods. The client can then decrypt the secrets whose policies it can satisfy. The client is expected to immediately extend PCR #11 so that long-term secrets whose policies expect PCR #11 to be in its initial state (all zeros) cannot again be decrypted with the client's TPM without first rebooting. Note that we use the server uses TPM2_MakeCredential() to construct the response, much like the \"WK method\" of encrypting secrets, with these differences: the client's ephemeral AKpub is used to construct the objectName input parameter, (This means that if the client reboots it will not be able to decrypt this response with TPM2_ActivateCredential() because the AK had stClear set, which means it cannot be recovered if the TPM is reset.) the objectName does not involve a policyDigest the ciphertext is not a long-term stable ciphertext but one made with an ephemeral AES-256 session key. Authentication of Enrolled Assets All enrolled assets are signed by a private key on the enrollment server at the time that the assets are created. Attestation clients validate these signatures after successful attestation and conveyance of enrolled assets to the attestation client. Signatures can be made with a bare key, or they can be made with a certified key. In the former case the attestation client must know the public key to validate the signatures with. In the latter case the attestation client must know a PKIX trust anchor for validating the enrollment server's certificate and certificate chain. Proof-of-Possession Protocol TBD (not yet designed or implemented). Attestation clients cannot recover their secrets unless they are in the attested state, or unless they ran untrusted code and locally saved their enrolled assets from a previous attestation. The attestation server currently receives no confirmation of that state after the fact, but knows that the client can recover its secrets IFF its attestation is correct because the client's TPM will enforce the binding between the client's EK and AK , and any policies needed to decrypt the client's enrolled assets. We are considering chaining instances of the attestation protocol where each instance proves activation of the preceding instance's credential. Thus the proof-of-posession (PoP) protocol would be the same as the attestation protocol. We might also use attestation chaining in this way to implement continuous (frequent) attestation. We can then keep some mutable per-device state, mainly the resetCount , time of last good attestation, and a sequence number of the last good attestation. Use Cases for PoP Protocols logging and alerting unlocking attested device access to a wider network locking out of the network devices that fail to attest frequently Enrollment Database NOTE: Nothing here formally specifies a schema for this database. This content is supplied only to help reviewers. The enrollment server creates state that is shared with attestation servers. Attestation servers need only read access to that state. We shall call that state a \"database\". Many options exist for representing the enrolled device database: relational (e.g., any SQL server) any NoSQL a filesystem a Git repository (basically a filesystem) Each enrolled asset, with all its encryptions and signatures, can be a BLOB value in a SQL table's column, or a file in a filesystem, or base64-encoded as a field in a JSON/YAML/etc file, or any similar concept. These blobs must be named, since the tarball sent to the client requires names for them. NOTE: Currently the sbin/attest-enroll program uses the filesystem to access the enrollment DB. Configurable hooks allow a site to convert the filesystem representation to other representations. One upcoming use will be to use a CHECKOUT hook to fetch a client's current entry from the DB and a COMMIT hook to commit a client's new current entry in the DB, using a Git repository to encode the client's entry as left on the filesystem by sbin/attest-enroll . Enrollment Database Contents Every enrolled device is identified by the SHA-256 digest of its EKpub (in TPM2B_PUBLIC format). This is also the cryptographic name of the device's TPM's EKpub . NOTE: In our current implementation this digest is part of the path to the enrolled device's filesystem-based database entry: $DBDIR/${ekhash:0:2}/${ekhash}/ Every enrolled device's enrolled state consists for the following named blobs. The blobs' names denote the expected type of their contents. Blobs: manifest (metadata) A textual (ASCII), newline-separated list of enrolled assets' blob names. manifest.sig (metadata) A digital signature of the manifest. ek.pub The enrolled device's EKpub , in TPM2B_PUBLIC format. hostname (metadata) The enrolled device's fully-qualified hostname. For each non-secret metadata: ${name} A blob containing some metadata of type identified by its name. ${name}.sig This is a digital signature the contents of the ${name} blob. For each type of secret: ${secret_name}.enc This is the secret itself, symmetrically encrypted in confounded AES-256-CBC-HMAC-SHA-256, with a unique symmetric key (see item below). ${secret_name}.enc.sig This is a signature of the ciphertext of the symmetrically encrypted secret. ${secret_name}.symkeyenc This is the AES-256 key used to encrypt the the previous item, itself encrypted to the device's TPM's EKpub . (In this case using the \"WK\" method.) ${secret_name}.policy Identifies (as a policyDigest value, hex-encoded in ASCII) or defines a policy used to encrypt the previous item ( ${secret_name}.symkeyenc ). NOTE: A policy definition language will be documented in an appendix later. escrow-${escrow_agent_names[0]}.symkeyenc escrow-${escrow_agent_names[1]}.symkeyenc .. escrow-${escrow_agent_names[$n]}.symkeyenc These are the ${secret_name}.symkey , each encrypted to the corresponding escrow agents, if any such are defined. The names and types of secrets need not be specified here, but currently we have support for the following: rootfs.key (a symmetric key(s) for local storage encryption) cert-priv.pem (a private key to a public key digital signature cryptosystem) keytab (a file containing one or more Kerberos \"key table\" entries with keys for the device's host service principals) The names and types of non-secret data blobs need not be specified here, but currently we have support for the following: Metadata types: anchor.pem (a trust anchor for the enrollment server's signing key) signer.pem (the enrollment server's public signing key) chain.pem (the enrollment server's signing key's PKIX certificate chain) hostname (see above) cert.pem (a certificate for cert-key.pem naming hostname ) Metadata files are also signed, thus if there is a something there will be a something.sig . Except that anchor.pem , signer.pem , and chain.pem are not signed, as there is no point to signing them. NOTE: The anchor.pem , signer.pem , and chain.pem are sent back to the attestation client, if present in the client's enrolled device entry, but the attestation client is expected to know the anchor.pem or signer.pem` a priori. Including these allows for key rotation and trust-on-first-use (TOFU) semantics on the attestation client side. The Safeboot.dev attestation client does not implement TOFU semantics. Site-local Customization Things that may vary locally: enrollment service base URI Naturally, different users of Safeboot.dev may have different enrollment service URIs, which may even vary by datacenter, by rack, by client OS, etc. attestation service URIs Ditto. enrolled assets enrolled device database and schema EKpub validation TPM vendor root CAs configured for EKcert validation Implementation Considerations The entire client side of the Safeboot.dev attestation protocol is implemented in Bash using native command-line tools to interact with the TPM and to perform software cryptographic operations, such as tpm2-tools and OpenSSL. The reason for the client side being implemented mostly in Bash is that we intend to use PXE booting, and we need the Linux initramfs image to be small. Using Bash and standard command-line tools (typically coded in C) allows the Linux initramfs image that must contain them to be small. In particular, using Bash consumes much less space than any scripting language such as Python. Most of the server side of enrollment and attestation is also implemented in Bash, with some parts in Python. An alternative would be to code the entire stack in Rust. Security Considerations As with all TPM-based attestation protocols, the security of the protocols depends critically on the device's TPM being a legitimate, trusted TPM. A TPM can be implemented in software, but then it can only be trusted if it is implemented by a trusted implementor, and run in a trusted hypervisor, and used by a guest of the hypervisor. Otherwise we expect the use of discrete, hardware TPMs, or perhaps firmware TPMs in some cases. The attestation server response is not authenticated. This means that any on-path attacker or any attacker that can redirect the client's communications with the server, can impersonate an attestation server and feed the client arbitrary secrets and metadata, but only if the attacker knows the client's EKpub . Since the client always tells the server it's EKpub , any attacker can impersonate the attestation server. Because all the enrolled assets are signed, all the enrolled assets are sent to the client, and a manifest of them is signed and sent to the client, no attacker can impersonate the attestation server without having access to the client's enrolled assets. An attacker that can impersonate the attestation server can furnish the enrolled assets to a client that is in an untrusted state. Therefore we consider the enrolled asset database to be read-sensitive. Only enrollment servers and attestation servers should be able to read it. Separation of enrollment and attestation server roles is not required, but enables privilege separation such that attestation servers need only read from the database, while enrollment servers need only write (for /v1/add and /v1/delete ) and also read (for /v1/query and /v1/find ). An attacker that can write to the enrollment database can also substitute its own assets, but only if it can sign them as a legitimate enrollment server would. Strict authorization of access to the enrollment server's signing credential is REQUIRED. The enrollment server can implement TOFU enrollment or authenticated and authorized enrollment. In the case of TOFU enrollment, binding of device EKpub and device name must be atomic. In the case of authenticated and authorized enrollment, the enrollment server MUST authenticate the user enrolling a device, and it MUST check if the user is authorized to do so (and possibly it must check if the user is authorized to create devices with names like the proposed name). We use a single round trip attestation protocol because, if the enrolled device EKpub is really for a TPM (and this MUST have been validated), then the semantics of TPM2_ActivateCredential() and the AKpub attribute validation done by the attestation server, together serve to provide us with all the guarantees we need that the PCR quote was legitimate. A proof-of-possession protocol is strictly optional, but it can help provide alerting. Analysis An attacker may not impersonate an attestation server without having read access to the database of enrolled assets. If we add use of TPM2_PolicySigned() then an attacker may not impersonate an attestation server without having read access to the database of enrolled assets and having access to the attestation server's signing credential. Digital signatures on the manifest of enrolled assets prevent attackers able to impersonate attestation servers from being able to add or remove enrolled assets. Digital signatures on enrolled assets prevent attackers able to impersonate attestation servers from being able to modify enrolled assets. Use of HTTPS (TLS) prevents impersonation of enrollment servers. Attestation of trusted state (PCRs) coupled with tight read access controls on the enrollment database prevent attackers who gain control of an attestation client from recovering the client's enrolled long-term secrets' plaintext: the attacker would have to compromise the client in such a way that the quoted PCRs do not reveal the fact of the client's compromise to the attestation service. However, it is essential that the attestation client have a locally configured trust anchor for validating the digital signatures on its enrolled assets. Replays of attestation client requests will be rejected if the nonce (really, timestamp) is too old. Otherwise they will be accepted, but attacker gets nothing from the response unless they have access to the client's TPM's EKpub and the AK that was used by the client. Replays of previous attestation service responses will not be accepted by the client since they will be bound to attestation keys no longer available on the client's TPM (because each AK used in attestation has the stClear attribute, so it will not be usable across reboots). If an attestation client performs attestation multiple times between reboots, then earlier responses can be replayed if the client depends on the server returning the client's ak.ctx file to it. However, since the contents returned to the client are static, there is no value to this replay attack. Alterations of attestation service responses by MITMs will be detected due to the use of authenticated symmetric encryption (via confounded AES-256-CBC-HMAC-SHA-256). Attackers who do not have access to an attestation client's TPM's EK cannot decrypt the attestation response. Impersonation of attestation services by attackers who can read the attestation database will be detected IFF the attacker removes, replaces, or adds enrolled assets and the attacker has not compromised the enrollment server's digital signing key or its PKI. A client that saves its enrolled assets in local storage can skip attestation going forward. As the intent is that clients attest at boot time, this is a problem. One can deal with this problem by ensuring that clients run only trusted code that wouldn't do that. NOTE: It may be desirable to develop an attestation protocol for frequent attestation. Such a protocol wouldn't deliver enrolled assets to the client, ensuring only that the client continues to be in a trusted state. Such a protocol is out of scope for this document at this time. Possible Improvements @osresearch proposes that we can use a policy to make sure that enrolled assets delivered to an attestation client cannot be decrypted unless the client attested to trusted state. We could do this using TPM2_PolicySigned() with a public key whose private key the attestation server possesses. The attestation client would then not be able to decrypt any of its enrolled encrypted assets without first getting a signature from the attestation server, which signature the attestation server would not provide unless it were happy with the client's attested state. The signature would be part of the response payload wrapper in a TPM2_MakeCredential() bound to the client's AK that has stClear . A key benefit of this approach is that the enrolled assets database would no longer be read-sensitive. We can get a stronger guarantee that the client's attested state is not spoofed by attaching a policy to the client's AK that binds the attested state, though this is racy (since the attested state can change during the attestation process, though in early boot it wouldn't). A client could avoid the race by starting and satisfying a corresponding policy session before engaging in the attestation protocol. With the current protocol the binding of attested state to the client's ability to \"activate\" the attestation server's response is only this: that the client must have access to the AK it used and that that AK must have fixedTPM | fixedParent | stClear | sign as its attributes. Associating a policy with the AK that uses TPM2_PolicyPCR() and TPM2_PolicyCounterTimer() to bind all the attested state would leave just one item unbound: the nonce (really, timestamp). We could use the nonce as a password to satisfy an authValue , using TPM2_PolicySecret() . Thus we could get a much stronger binding of the attested state to the client's ability to activat the attestation response. That said, the current, weaker, binding that we have in the protocol seems sufficient for our current purposes. Consider having attestation update some state on the server side for detection of resetCount going backwards (replay detection), and replay detection more generally when we start performing proof-of-possession and frequent re-attestation. Because we prize availability, we may use an eventually-consistent method of sharing mutable attestation state on the server side. Securing Communications with TPMs Depending on the threat model it is essential to use encryption sessions to encrypt sensitive command/response parameters, and to authenticate all commands and responses. Authentication of communications with a TPM depends on the application knowing the TPM's EKpub . Sadly, it is not commonly the case that a computer's BIOS knows the computer's TPM's EKpub from factory. As a result, it is possible for invasive, physical MITM attacks on TPMs. Once a device's TPM's EKpub is enrolled, any MITM has to be in the middle every time the attestation client runs. Therefore the MITM has to have been in the middle from the moment the device is enrolled. Configuring Trust Anchors Attestation clients configured to use secure boot can find a locally configured trust anchor on local storage after successful decryption with a rootfs key. The rootfs key can be decrypted without authenticating its signature because if it can decrypt the local filesystem then the rootfs key must not have been altered by any attacker. Attestation clients that are not configured to use secure boot can find a locally configured trust anchor on local storage, or in a TPM \"non-volatile (NV) index\" (in the case of a TPM NV index, probably only a hash of the trust anchor would be stored in the NV index). In any case, authentication key rotation would be difficult. Indirection via intermediate keys (PKI-style) would help. EKpub Validation We rely utterly on TPMs enforcing extended policies. This means that we must know that some EKpub is indeed a TPM's EKpub . External EKpub Validation (Google Compute Environment) In the Google Compute Environment the Google Shielded VM product allows us to lookup a device by name and obtain its EKpub in PEM format. If authorized users of the enrollment service can be trusted to fetch the EKpub from the Google Shielded VM API, then the enrollment server need not validate the EKpub at all -- the attestation server can just trust the given EKpub . EKpub Validation using EK Certificates When enrolling bare-metal hardware, as opposed to Google Shielded VMs, we must either extract the to-be-enrolled device's TPM's EKpub manually, and once more trust and allow only authorized users of the enrollment service to enroll those, or we must extract the to-be-enrolled device's TPM's EKcert and enroll that so that the enrollment server may validate the client's EKcert is issued by a trusted TPM vendor. XXX We have yet to implement this. Alternatives to EKpub s Any primary key object with the fixedTPM , fixedParent , and decrypt attributes set is suitable as an substitute for the EKpub provided that the process of calling TPM2_CreatePrimary() and reading its public key is secured by using the EKpub , and that the legitimacy of the TPM is established. Wherever we refer to an EKpub in this document, one may substitute such an alternative key. Appendix A: Symmetric AEAD Cipher Mode: Confounded AES-256-CBC-HMAC-SHA-256 For bulk encryption we use AES-256 with an authenticated encryption with additional data (AEAD) cipher mode. Given our implementation constraints we ended up using a cipher mode based on the well-understood Kerberos cryptosystem specified in RFCs 3962 and 8009 . Kerberos uses AES with the CipherText Stealing (CTS) cipher mode, confounded, and with an HMAC with a SHA family digest. CTS is a variation of Cipher Block Chaining mode (CBC). The differences between our confounded AES-256-CBC-HMAC-SHA-256 and the Kerberos cipher modes are: we use CBC instead of CTS we use SHA-256 with AES-256 we don't truncate the HMAC NOTE: Well, we could use SHA-384 with AES-256 for the HMAC, but then again, we're not truncating the HMAC. NOTE: \"Confounding\" consists of prepending to the plaintext a cipherblock's worth (16 bytes) of randomly generated bits. This causes the ciphertext resulting from the encryption of the \"confounder\" to function as the actual, non-zero IV for the plaintext. Confounded CBC is indistinguishable from CBC with explicit IV, except that it costs one more cipher block operation, so it is slightly slower. NOTE: CTS is a variation of CBC that does not require padding. It does not work for plaintexts shorter than a cipher block (16 bytes), but since confounding means prefixing a cipher block's worth of nonce to the plaintext, confounded CTS always expands the plaintext by just one cipher block's worth, and does not require padding. Therefore a plaintext that is 30 bytes will yield a ciphertext that is 46 bytes (+ 32 more bytes for the HMAC), a 31 byte plaintext will yield a 47 byte ciphertext, etc. Replacing CTS with CBC does not enable any further cryptanalysis since, after all, CTS applied to plaintexts of length divisible by the cipher's block size is equivalent to CBC. NOTE: When we switch to using OpenSSL 3.0 we will be able to use CTS instead of CBC. NOTE: The primary reason for using this construction is that it is easily implemented in Bash with OpenSSL 1.x tooling, and OpenSSL 1.x tooling does not provide authenticated encryption constructions in its command-line tools that are suitable for encrypting data at rest. To encrypt a secret the enrollment server: creates a random AES-256 key uses confounded AES-256-CBC-HMAC-SHA-256: a. uses AES-256 in cipher block chaining (CBC) mode with all-zero IV confounding (a cipherblock's worth of entropy prepended to the plaintext) padding b. appends an HMAC-SHA-256 digest of the resulting ciphertext The padding is per-OpenSSL (if the plaintext is a whole multiple of 16 bytes then 16 bytes of zeros are added, else as many bytes are appended to bring the plaintext size to a whole multiple of 16 bytes, with the last byte set to the count of padding bytes). The resulting ciphertexts are stored as-is in the enrollment DB. The per-secret AES-256 keys are encrypted to the device's TPM's EKpub, and to the escrow agents. Decryption of confounded AES-256-CBC-HMAC-SHA-256 ciphertexts is as follows: compute the HMAC-SHA-256 MAC of the ciphertext (excluding the MAC in the ciphertext) constant-time compare the computed MAC to the MAC in the ciphertext if these do not match, fail decrypt the ciphertext (excluding the MAC) with AES-256 in CBC mode discard the first block of the resulting plaintext (the confounder) examine the last byte of the plaintext and drop the indicated amount of padding","title":"Safeboot.dev Enrollment, Attestation, and Proof-of-Possession Protocols"},{"location":"protocol/#safebootdev-enrollment-attestation-and-proof-of-possession-protocols","text":"This document describes the Safeboot.dev enrollment and attestation protocols. These protocols are based on the Trusted Computing Group's (TCG) Trusted Platform Module (TPM), using a discrete TPM or a firmware TPM to secure enrollment and delivery of secrets to enrolled devices. The use of a TPM helps provide decent assurance of device state at certain times, provides us with a way to bootstrap trust. The Safeboot.dev enrollment protocol creates long-term state for an enrolled device, including secrets/credentials needed by the device. The Safeboot.dev attestation protocol conveys enrolled state to devices that demonstrate being in good state. NOTE: The protocol is described as it will soon be. Specifically, the use of digital signatures for authentication of long-term enrolled assets is not yet integrated. See Pull Request #140 .","title":"Safeboot.dev Enrollment, Attestation, and Proof-of-Possession Protocols"},{"location":"protocol/#goals","text":"protocol specification sufficient for security review","title":"Goals"},{"location":"protocol/#background","text":"The security of the Safeboot.dev protocols depends critically on the use of TPMs. Reviewers must be familiar with some of the relevant TPM concepts listed below. Some useful links: Introduction to TPMs Device Enrollment What Attestation Is","title":"Background"},{"location":"protocol/#critical-background","text":"It is essential that readers understand: TPM2_MakeCredential() TPM2_ActivateCredential() Cryptographic object naming Readers should also have a passing understanding of how authorization works in a TPM 2.0 as well, especially when a TPM requires a caller to execute some authorization policy, and which policy. Readers must be familiar with the TPM2_MakeCredential() / TPM2_ActivateCredential() constructs. We describe these somewhat here. TPM2_MakeCredential() is an operation that amounts to encryption of a small secret to a public key, but with a binding to the cryptographic name of an \"activation object\". TPM2_ActivateCredential() decrypts such ciphertexts provided that: the caller has access to the private key to whose public key TPM2_MakeCredential() encrypted the payload, and that the caller has access to the \"activation object\" named by the caller of TPM2_MakeCredential() . As the cryptographic name of an object binds to it any authorization policies associated with use of that object, the caller of TPM2_ActivateCredential() must meet that policy. This means that the caller of TPM2_MakeCredential() can require specific authorization and other attributes -via the activation object's name- that the caller of TPM2_ActivateCredential() must satisfy. For example, a device that will call TPM2_ActivateCredential() can supply the activation object's public key to the peer that will call TPM2_MakeCredential() , then that peer can combine the activation object's public key with the attributes expected of the activation object to cause the protocol to succeed IFF the possessor of the activation object created it with those same attributes. NOTE: The activation object's private key is not itself used for any cryptographic operations in TPM2_ActivateCredential() . Only the activation object's cryptographic name and its attributes are used. NOTE: The TPM2_MakeCredential() function can be implemented entirely in software, as it requires no privileged access to any objects stored in any TPMs. NOTE: It is essential to the security of the Safeboot.dev protocols that enrolled devices' TPMs be legitimate TPMs or virtual TPMs run by trusted agents. This is due to the protocol depending on the TPM to enforce authorization policies for certain functions that an untrusted implementation could forgo.","title":"Critical Background"},{"location":"protocol/#other-tpm-background","text":"Some less critical TPM background: Hash extension Platform Configuration Registers (PCRs) Root of Trust Measurement (RTM) Authorization Key hierarchies","title":"Other TPM Background"},{"location":"protocol/#terminology","text":"We will use a lot of terminology from the TCG universe. In particular we will speak of: credential Depending on the context, \"credential\" will refer either to: a) a secret or private key and possibly some metadata which can be used to access some remote resources -- for example, a PKIX certificate and private key --, b) a small secret key -typically an AES key- encrypted with TPM2_MakeCredential() . credential activation The successful use of TPM2_ActivateCredential() to recover a small secret. activation object A TPM entity whose cryptographic name is used in making a \"credential\" with TPM2_MakeCredential() , and a handle and authorization session to which will be provided by the caller of TPM2_ActivateCredential() to recover the credential.","title":"Terminology"},{"location":"protocol/#use-cases-secure-boot-device-credential-provisioning","text":"The Safeboot.dev enrollment and attestation protocols support two use cases: secure boot device credential provisioning These two uses differ only in whether the enrolled device is expected to perform UEFI secure boot. In all cases Safeboot.dev enrollment is about creating sensitive files/blobs/assets that are stored encrypted to the device's TPM and to escrow agents. In all cases Safeboot.dev attestation is about delivering enrolled assets to devices in trusted state.","title":"Use Cases: Secure Boot, Device Credential Provisioning"},{"location":"protocol/#use-cases-secure-boot","text":"This use-case involves the device encrypting local storage with a secret long-term key obtained at boot time via the attestation protocol.","title":"Use Cases: Secure Boot"},{"location":"protocol/#use-cases-device-credential-provisioning","text":"This use-case involves delivering to the device credentials such as: private keys and PKIX certificates for their public keys (for, e.g., TLS and/or IPsec) Kerberos keys (\"keytabs\") OpenSSH host keys and certificates service account tokens of various kinds","title":"Use Cases: Device Credential Provisioning"},{"location":"protocol/#use-cases-secure-boot-and-device-credential-provisioning","text":"Naturally, both of these use cases can be combined. In fact, they are the same use case, differing only in the nature of the material delivered to the client.","title":"Use Cases: Secure Boot and Device Credential Provisioning"},{"location":"protocol/#use-cases-currently-out-of-scope","text":"Other attestation protocols are meant to be used not just at boot time but very often, and not so much for delivering device credentials to the client device as for ascertaining the continued trusted state of the client device. Devices that fail to attest successfully and often enough might, e.g., be locked out of the network. Such protocols may depend on having some dynamic state on the server side. For example, keeping track of the last time that a client attested, its TPM's resetCount (to make sure it never goes backward, and to detect reboots), etc. Nothing about Safeboot.dev's protocols precludes the use of other attestation protocols for purposes other than the use cases listed above. Nothing about Safeboot.dev's current protocols precludes the addition to Safeboot.dev of functionality similar to those other projects' attestation protocols'.","title":"Use Cases Currently Out of Scope"},{"location":"protocol/#threat-model","text":"The primary threats that the Safeboot.dev enrollment and attestation protocols seek to protect against are: theft of devices and/or their local storage passive attacks on the attestation protocol active attacks on the attestation protocol any attacks on the enrollment protocol","title":"Threat Model"},{"location":"protocol/#assumptions","text":"We assume that: enrollment and attestation servers are physically secure access to enrollment and attestation servers is secured the credentials held by enrollment and attestation servers are secure the enrollment database and any associated servers are secure read access to the enrollment database can be secured enrollment database protocols are secure","title":"Assumptions"},{"location":"protocol/#threat-models-out-of-scope","text":"The following threats are out of scope for this document: any attacks on the attestation server (other than via attacks on the attestation protocol) any attacks on the enrollment database any attacks on the enrollment server (other than via attacks on the enrollment protocol) post-attestation attacks on devices","title":"Threat Models Out of Scope"},{"location":"protocol/#architecture","text":"The Safeboot.dev architecture consists of two separate protocols: one for enrollment, and one for attestation. The Safeboot.dev attestation protocol operates using state created at enrollment time. Enrollment is the act of creating state binding a device's TPM and a name for that device, as well as creating any secrets and/or metadata that that device may repeatedly need in the environment it will be used in. The separation of enrollment and attestation is motivated by: privilege separation considerations We'd like to isolate any issuer credentials to as few systems as possible, while allowing the attestation service to be widely replicated. Because enrollment is a low-frequency event, while attestation a high-frequency event, we can have fewer enrollment servers and more attestation servers. Then we can isolate issuer credentials by placing them only on enrollment servers. database replication and write concurrency considerations Having state created and manipulated only at enrollment servers allows us to replicate the enrollment database to attestation servers as a read-only database. Together with the low frequency of enrollment events this frees us from having to address concurrent database updates at this time, at the cost of having primary/secondary enrollment server roles. Any future evolution of Safeboot.dev towards more dynamic attestation state may well use separate databases for enrolled assets and attestation state. Our interest in privilege separation does not preclude such an evolution, as the separation between one database type and the other would tend to fulfill that interest.","title":"Architecture"},{"location":"protocol/#enrollment-protocol","text":"The enrollment protocol cosists of an HTTP API called over HTTPS: /v1/add -- POST here to enroll, as described above /v1/find -- GET here to query the enrolled device database by hostname /v1/query -- GET here to query the enrolled device database by EKhash /v1/delete -- POST here to delete an enrolled device's database entry All of these end-points are 1 round trip, naturally (except where HTTP authentication methods used require more round trips). The /v1/add and /v1/delete end-points expect an HTML form to be posted. The /v1/find end-point expects a single query parameter to be given: hostname , with a hostname prefix. The /v1/query end-point expects a single query parameter to be given: ekpubhash , with a hash of EKpub prefix. The /v1/add end-point takes two inputs from the client, delivered as an HTML form over an HTTPS POST: hostname -- the desired device name ekpub -- the device's TPM's endorsement public key ( EKpub ), either in TPM2B_PUBLIC or PEM formats (either as a public key or as a certificate) An EK certificate is preferred, as that can be validated by checking that its issuer chains to a trusted TPM vendor root certification authority (CA). In environments such as the Google compute cloud's Shielded VMs, there may not be an EK certificate available, but instead an API may be available to validate an EKpub . User authentication and authorization MAY be required if only certain users should be allowed to enroll devices. The choice of HTTP authentication method is not specified here (options include Negotiate, Bearer, OIDC, SCRAM, etc.). The enrollment server ensures that the creation of the binding of device name and EKpub is made atomically. NOTE: In a putative future where multiple enrollment servers can concurrently create these bindings, we may dispense with atomic bindings; instead a conflict resolution mechanism MAY be used to resolve conflicts. The enrollment server will also provision the device with any number of secrets and metadata of various kinds that will be transported to the device during attestation. These are stored encrypted at rest (more on this below). No request or response headers are used. No universal resource identifier (URI) query-parts are used. The URI local-part need only denote that it is the enrollment end-point. We are using the following URI local-parts:","title":"Enrollment Protocol"},{"location":"protocol/#types-of-secrets-and-metadata-provisioned","text":"Various types of long-term secrets and metadata can be provisioned to an enrolled device: configuration early boot scripts symmetric keys (or passphrase) for local storage encryption private keys and PKIX certificates for them (client, server) for TLS, IPsec, etc. Kerberos keys (\"keytab\") service account tokens IPsec keys for manually keyed SAs etc. IMPLEMENTATION NOTE: These are configurable as genprog s for the sbin/attest-enroll program. See its usage message.","title":"Types of Secrets and Metadata Provisioned"},{"location":"protocol/#data-at-rest-encryption","text":"All these secrets created by the /v1/add end-point are encrypted to the device's TPM's EKpub and separately also encrypted to the public keys of configured escrow agents for, e.g., break-glass recovery. For every secret asset the server generates a random AES-256 key. The plaintext of the secret to be encrypted is then encrypted using the AES-256 key in an authenticated encryption cipher mode. See Appendix-A . The AES-256 key is then encrypted to the enrolled device's EKpub and to any configured escrow agents' public keys.","title":"Data-at-Rest Encryption"},{"location":"protocol/#encryption-to-escrow-agents","text":"Encryption to escrow agents is done using raw RSA public keys.","title":"Encryption to Escrow Agents"},{"location":"protocol/#encryption-to-device-ekpub","text":"All these secrets are encrypted to the device's TPM's EKpub , each with an optional, configurable TPM authorization policy. Two mechanisms can be used for encryption to a device's TPM: the \"WK\" and \"TK\" mechanisms. A TPM authorization policy is a TPM 2.0 enhanced authorization (EA) policy, and will be enforced by the device's TPM when called to decrypt one of these secrets. The default policy for the rootfs key (a symmetric key for local storage encryption) is that the platform configuration register (PCR) #11 must have the initial value (all zeros), with the expecation that the attestation client will immediately extend PCR #11 (with no particular value -- just some value) so that the TPM will not again decrypt the same ciphertext unless the device reboots. Policies are configurable for each secret type. NOTE: We could use well-known PCR#11 extension values for the purpose of creating specific time windows during the boot process during which different secrets could be decrypted. NOTE: Both, the WK and TK methods offer equivalent functionality. We support both mainly for historical reasons. The WK method is simpler, but the TK method was implemented first.","title":"Encryption to Device EKpub"},{"location":"protocol/#encryption-to-tpm-ekpub-wk-method","text":"NOTE: Readers are expected to understand the TPM2_MakeCredential() and TPM2_ActivateCredential() functions. See the Critical Background section . A well-known public key ( WK ) is loaded into a software TPM using TPM2_LoadExternal() with the desired policy's policyDigest . TPM2_MakeCredential() is called with these input parameters: the WKpub (the loaded WK) as the objectName input parameter, the device's EKpub as the handle input parameter, and the AES-256 symmetric key as the credential input parameter (the plaintext). The outputs of TPM2_MakeCredential() ( credentialBlob and secret ) make up the ciphertext of the AES-256 key encrypted to the TPM's EKpub . The details of what TPM2_MakeCredential() does are described in the TCG TPM 2.0 Library part 1: Architecture, section 24 (Credential Protection) . Decryption is done by calling TPM2_ActivateCredential() on the TPM that has the EK corresponding to the EKpub . Critically, the TPM will refuse to \"activate\" the credential (i.e., decrypt the ciphertext) unless the caller has satisfied the WK's authPolicy (if set). To decrypt, access to the TPM identified by the EKpub is needed. The process is as follows: call TPM2_LoadExternal() the well-known key, with the desired authPolicy , if any call TPM2_StartAuthSession() to create a policy session for the EK call TPM2_PolicySecret() to obtain access to the EK call TPM2_StartAuthSession() to create a policy session for the WK (if the WK had a policyDigest set) call the policy commands on the WK session handle to satisfy its policy (if one was set) call TPM2_ActivateCredential() with the loaded WK as the activateHandle and its corresponding policy session, the EK as the keyHandle and its corresponding policy session, and the ciphertext ( credentialBlob and secret ) as input parameters The WK 's authorization policy, if set, is enforced by TPM2_ActivateCredential() . Then, once the AES-256 key is decrypted, the confounded AES-256-CBC-HMAC-SHA256 ciphertext is decrypted as described above.","title":"Encryption to TPM EKpub: WK Method"},{"location":"protocol/#encryption-to-tpm-ekpub-tk-method","text":"create an RSA key-pair in software encrypt the AES-256 key to the RSA public key using OEAP with any software use a software TPM to encrypt the RSA private key from (1) to the EKpub of the target TPM using TPM2_Duplicate() , setting the desired policy's policyDigest as the intended authPolicy of the RSA key as it will be when loaded by the target TPM the ciphertext then consists of a) the ciphertext from encryption to the RSA public key, b) the outputs of TPM2_Duplicate() To decrypt, access to the TPM identified by the EKpub is needed. The process is as follows: call TPM2_StartAuthSession() to create a policy session for the EK call TPM2_PolicySecret() to obtain access to the EK call TPM2_Import() and TPM2_Load() to import and load the output of TPM2_Duplicate() call TPM2_StartAuthSession() to create a policy session for the TK (if the TK had a policyDigest set) call the policy commands on the WK session handle to satisfy its policy (if one was set) call TPM2_RSA_Decrypt() to decrypt the AES-256 key with the imported TK The TK 's authorization policy, if set, is enforced by TPM2_RSA_Decrypt() . Then, once the AES-256 key is decrypted, the confounded AES-256-CBC-HMAC-SHA256 ciphertext is decrypted as described above.","title":"Encryption to TPM EKpub: TK Method"},{"location":"protocol/#break-glass-recovery","text":"Break-glass recovery consists of: replacing a device's TPM or the device itself (including its TPM), decrypting the secret AES-256 keys stored in the enrollment DB using an escrow agent, encrypting those to the new TPM's EKpub , and replacing the corresponding ciphertexts in the enrolled device's entry in the enrollment DB. Any break-glass recovery operations must be performed only by authorized users.","title":"Break-Glass Recovery"},{"location":"protocol/#attestation-protocol","text":"The Safeboot.dev attestation protocol is a single round trip protocol that allows a device to obtain its enrolled assets from the attestation server in exchange for successfully attesting to the device's state. State that can be attested: recency -- via a timestamp that the caller has access to the EK the values of PCRs, which reflect the firmware ROMs and operating system loaded the TPM's resetCount (count of reboots) anything that can be required by a TPM policy To attest its state, a client device first generates an \"attestation key\" ( AK ) -- an asymmetric signing keypair. This object must have the stClear attribute set, which means that the TPM will refuse to reload or re-create this AK if the TPM is reset (which happens when the host device reboots). It must also have the fixedTPM , fixedParent , and sign attributes set. Then the client creates a \"quote\" of all the PCRs, signed with the AK . See TPM2_Quote() . The attestation protocol consists of an HTTP POST (HTTPS not required) with: /v1/attest as the end-point no particular request headers no URI query-parameters no HTTP authentication needed the request body consisting of an uncompressed tar file containing the following items: ek.crt -- the EKcert , that is, the PKIX certificate for the TPM's endorsment key (EK) as provisioned by the TPM's vendor (this is optional, present only if the TPM has an EKcert ) ek.pub -- the EKpub in TPM2B_PUBLIC format ak.pub -- the TPM2B_PUBLIC representation of the AK ak.ctx -- the AK object, saved to help make it easier for the client to keep state quote.out , quote.sig , and quote.pcr -- the outputs of TPM2_Quote() using the AK nonce -- not actually a nonce but a timestamp as seconds since the Unix epoch eventlog -- if possible, this is the TPM PCR eventlog kept by the UEFI BIOS ima -- if possible, this is the Linux IMA log The attestation server then: looks up the device's enrollment DB entry by the given EKpub examines the ak.pub to ensure that it has the desired attributes (specifically: sign fixedTPM fixedParent stClear and recomputes the AK 's cryptographic name for later use as the activation object name request parameter of TPM2_MakeCredential() verifies that the eventlog matches the PCRs verifies that the digests that appear in the eventlog are acceptable, or that the PCRs match \"golden PCRs\" examines the nonce to verify that it is a recent timestamp If all the validation steps succeed, then the attestation server: generates an ephemeral AES-256 session key, constructs a tarball of the device's long-term enrolled assets from the device's enrollment database entry, encrypts that tarball in the session key, encrypts the session key to the device's TPM's EKpub using TPM2_MakeCredential() with the AKpub 's cryptographic name as the objectName and the EKpub as the handle In the successful case, then, the response body is a tarball consisting of: credential.bin -- a file containing the credentialBlob and secret output parameters of the TPM2_MakeCredential() call cipher.bin -- the ciphertext of a tarball of the device's enrollment DB entry, encrypted with the AES-256 session key using confounded AES-256-CBC-HMAC-SHA-256 as described above. ak.ctx (as provided by the client, sent back) The client can decrypt and recover the AES-256 session key IFF it has a TPM with the corresponding EK and AK loaded. Having recovered the AES-256 session key, the client can decrypt the tarball of the client's long-term secrets and metadata, where the secrets are encrypted to the client's TPM using the WK or TK methods. The client can then decrypt the secrets whose policies it can satisfy. The client is expected to immediately extend PCR #11 so that long-term secrets whose policies expect PCR #11 to be in its initial state (all zeros) cannot again be decrypted with the client's TPM without first rebooting. Note that we use the server uses TPM2_MakeCredential() to construct the response, much like the \"WK method\" of encrypting secrets, with these differences: the client's ephemeral AKpub is used to construct the objectName input parameter, (This means that if the client reboots it will not be able to decrypt this response with TPM2_ActivateCredential() because the AK had stClear set, which means it cannot be recovered if the TPM is reset.) the objectName does not involve a policyDigest the ciphertext is not a long-term stable ciphertext but one made with an ephemeral AES-256 session key.","title":"Attestation Protocol"},{"location":"protocol/#authentication-of-enrolled-assets","text":"All enrolled assets are signed by a private key on the enrollment server at the time that the assets are created. Attestation clients validate these signatures after successful attestation and conveyance of enrolled assets to the attestation client. Signatures can be made with a bare key, or they can be made with a certified key. In the former case the attestation client must know the public key to validate the signatures with. In the latter case the attestation client must know a PKIX trust anchor for validating the enrollment server's certificate and certificate chain.","title":"Authentication of Enrolled Assets"},{"location":"protocol/#proof-of-possession-protocol","text":"TBD (not yet designed or implemented). Attestation clients cannot recover their secrets unless they are in the attested state, or unless they ran untrusted code and locally saved their enrolled assets from a previous attestation. The attestation server currently receives no confirmation of that state after the fact, but knows that the client can recover its secrets IFF its attestation is correct because the client's TPM will enforce the binding between the client's EK and AK , and any policies needed to decrypt the client's enrolled assets. We are considering chaining instances of the attestation protocol where each instance proves activation of the preceding instance's credential. Thus the proof-of-posession (PoP) protocol would be the same as the attestation protocol. We might also use attestation chaining in this way to implement continuous (frequent) attestation. We can then keep some mutable per-device state, mainly the resetCount , time of last good attestation, and a sequence number of the last good attestation.","title":"Proof-of-Possession Protocol"},{"location":"protocol/#use-cases-for-pop-protocols","text":"logging and alerting unlocking attested device access to a wider network locking out of the network devices that fail to attest frequently","title":"Use Cases for PoP Protocols"},{"location":"protocol/#enrollment-database","text":"NOTE: Nothing here formally specifies a schema for this database. This content is supplied only to help reviewers. The enrollment server creates state that is shared with attestation servers. Attestation servers need only read access to that state. We shall call that state a \"database\". Many options exist for representing the enrolled device database: relational (e.g., any SQL server) any NoSQL a filesystem a Git repository (basically a filesystem) Each enrolled asset, with all its encryptions and signatures, can be a BLOB value in a SQL table's column, or a file in a filesystem, or base64-encoded as a field in a JSON/YAML/etc file, or any similar concept. These blobs must be named, since the tarball sent to the client requires names for them. NOTE: Currently the sbin/attest-enroll program uses the filesystem to access the enrollment DB. Configurable hooks allow a site to convert the filesystem representation to other representations. One upcoming use will be to use a CHECKOUT hook to fetch a client's current entry from the DB and a COMMIT hook to commit a client's new current entry in the DB, using a Git repository to encode the client's entry as left on the filesystem by sbin/attest-enroll .","title":"Enrollment Database"},{"location":"protocol/#enrollment-database-contents","text":"Every enrolled device is identified by the SHA-256 digest of its EKpub (in TPM2B_PUBLIC format). This is also the cryptographic name of the device's TPM's EKpub . NOTE: In our current implementation this digest is part of the path to the enrolled device's filesystem-based database entry: $DBDIR/${ekhash:0:2}/${ekhash}/ Every enrolled device's enrolled state consists for the following named blobs. The blobs' names denote the expected type of their contents. Blobs: manifest (metadata) A textual (ASCII), newline-separated list of enrolled assets' blob names. manifest.sig (metadata) A digital signature of the manifest. ek.pub The enrolled device's EKpub , in TPM2B_PUBLIC format. hostname (metadata) The enrolled device's fully-qualified hostname. For each non-secret metadata: ${name} A blob containing some metadata of type identified by its name. ${name}.sig This is a digital signature the contents of the ${name} blob. For each type of secret: ${secret_name}.enc This is the secret itself, symmetrically encrypted in confounded AES-256-CBC-HMAC-SHA-256, with a unique symmetric key (see item below). ${secret_name}.enc.sig This is a signature of the ciphertext of the symmetrically encrypted secret. ${secret_name}.symkeyenc This is the AES-256 key used to encrypt the the previous item, itself encrypted to the device's TPM's EKpub . (In this case using the \"WK\" method.) ${secret_name}.policy Identifies (as a policyDigest value, hex-encoded in ASCII) or defines a policy used to encrypt the previous item ( ${secret_name}.symkeyenc ). NOTE: A policy definition language will be documented in an appendix later. escrow-${escrow_agent_names[0]}.symkeyenc escrow-${escrow_agent_names[1]}.symkeyenc .. escrow-${escrow_agent_names[$n]}.symkeyenc These are the ${secret_name}.symkey , each encrypted to the corresponding escrow agents, if any such are defined. The names and types of secrets need not be specified here, but currently we have support for the following: rootfs.key (a symmetric key(s) for local storage encryption) cert-priv.pem (a private key to a public key digital signature cryptosystem) keytab (a file containing one or more Kerberos \"key table\" entries with keys for the device's host service principals) The names and types of non-secret data blobs need not be specified here, but currently we have support for the following: Metadata types: anchor.pem (a trust anchor for the enrollment server's signing key) signer.pem (the enrollment server's public signing key) chain.pem (the enrollment server's signing key's PKIX certificate chain) hostname (see above) cert.pem (a certificate for cert-key.pem naming hostname ) Metadata files are also signed, thus if there is a something there will be a something.sig . Except that anchor.pem , signer.pem , and chain.pem are not signed, as there is no point to signing them. NOTE: The anchor.pem , signer.pem , and chain.pem are sent back to the attestation client, if present in the client's enrolled device entry, but the attestation client is expected to know the anchor.pem or signer.pem` a priori. Including these allows for key rotation and trust-on-first-use (TOFU) semantics on the attestation client side. The Safeboot.dev attestation client does not implement TOFU semantics.","title":"Enrollment Database Contents"},{"location":"protocol/#site-local-customization","text":"Things that may vary locally: enrollment service base URI Naturally, different users of Safeboot.dev may have different enrollment service URIs, which may even vary by datacenter, by rack, by client OS, etc. attestation service URIs Ditto. enrolled assets enrolled device database and schema EKpub validation TPM vendor root CAs configured for EKcert validation","title":"Site-local Customization"},{"location":"protocol/#implementation-considerations","text":"The entire client side of the Safeboot.dev attestation protocol is implemented in Bash using native command-line tools to interact with the TPM and to perform software cryptographic operations, such as tpm2-tools and OpenSSL. The reason for the client side being implemented mostly in Bash is that we intend to use PXE booting, and we need the Linux initramfs image to be small. Using Bash and standard command-line tools (typically coded in C) allows the Linux initramfs image that must contain them to be small. In particular, using Bash consumes much less space than any scripting language such as Python. Most of the server side of enrollment and attestation is also implemented in Bash, with some parts in Python. An alternative would be to code the entire stack in Rust.","title":"Implementation Considerations"},{"location":"protocol/#security-considerations","text":"As with all TPM-based attestation protocols, the security of the protocols depends critically on the device's TPM being a legitimate, trusted TPM. A TPM can be implemented in software, but then it can only be trusted if it is implemented by a trusted implementor, and run in a trusted hypervisor, and used by a guest of the hypervisor. Otherwise we expect the use of discrete, hardware TPMs, or perhaps firmware TPMs in some cases. The attestation server response is not authenticated. This means that any on-path attacker or any attacker that can redirect the client's communications with the server, can impersonate an attestation server and feed the client arbitrary secrets and metadata, but only if the attacker knows the client's EKpub . Since the client always tells the server it's EKpub , any attacker can impersonate the attestation server. Because all the enrolled assets are signed, all the enrolled assets are sent to the client, and a manifest of them is signed and sent to the client, no attacker can impersonate the attestation server without having access to the client's enrolled assets. An attacker that can impersonate the attestation server can furnish the enrolled assets to a client that is in an untrusted state. Therefore we consider the enrolled asset database to be read-sensitive. Only enrollment servers and attestation servers should be able to read it. Separation of enrollment and attestation server roles is not required, but enables privilege separation such that attestation servers need only read from the database, while enrollment servers need only write (for /v1/add and /v1/delete ) and also read (for /v1/query and /v1/find ). An attacker that can write to the enrollment database can also substitute its own assets, but only if it can sign them as a legitimate enrollment server would. Strict authorization of access to the enrollment server's signing credential is REQUIRED. The enrollment server can implement TOFU enrollment or authenticated and authorized enrollment. In the case of TOFU enrollment, binding of device EKpub and device name must be atomic. In the case of authenticated and authorized enrollment, the enrollment server MUST authenticate the user enrolling a device, and it MUST check if the user is authorized to do so (and possibly it must check if the user is authorized to create devices with names like the proposed name). We use a single round trip attestation protocol because, if the enrolled device EKpub is really for a TPM (and this MUST have been validated), then the semantics of TPM2_ActivateCredential() and the AKpub attribute validation done by the attestation server, together serve to provide us with all the guarantees we need that the PCR quote was legitimate. A proof-of-possession protocol is strictly optional, but it can help provide alerting.","title":"Security Considerations"},{"location":"protocol/#analysis","text":"An attacker may not impersonate an attestation server without having read access to the database of enrolled assets. If we add use of TPM2_PolicySigned() then an attacker may not impersonate an attestation server without having read access to the database of enrolled assets and having access to the attestation server's signing credential. Digital signatures on the manifest of enrolled assets prevent attackers able to impersonate attestation servers from being able to add or remove enrolled assets. Digital signatures on enrolled assets prevent attackers able to impersonate attestation servers from being able to modify enrolled assets. Use of HTTPS (TLS) prevents impersonation of enrollment servers. Attestation of trusted state (PCRs) coupled with tight read access controls on the enrollment database prevent attackers who gain control of an attestation client from recovering the client's enrolled long-term secrets' plaintext: the attacker would have to compromise the client in such a way that the quoted PCRs do not reveal the fact of the client's compromise to the attestation service. However, it is essential that the attestation client have a locally configured trust anchor for validating the digital signatures on its enrolled assets. Replays of attestation client requests will be rejected if the nonce (really, timestamp) is too old. Otherwise they will be accepted, but attacker gets nothing from the response unless they have access to the client's TPM's EKpub and the AK that was used by the client. Replays of previous attestation service responses will not be accepted by the client since they will be bound to attestation keys no longer available on the client's TPM (because each AK used in attestation has the stClear attribute, so it will not be usable across reboots). If an attestation client performs attestation multiple times between reboots, then earlier responses can be replayed if the client depends on the server returning the client's ak.ctx file to it. However, since the contents returned to the client are static, there is no value to this replay attack. Alterations of attestation service responses by MITMs will be detected due to the use of authenticated symmetric encryption (via confounded AES-256-CBC-HMAC-SHA-256). Attackers who do not have access to an attestation client's TPM's EK cannot decrypt the attestation response. Impersonation of attestation services by attackers who can read the attestation database will be detected IFF the attacker removes, replaces, or adds enrolled assets and the attacker has not compromised the enrollment server's digital signing key or its PKI. A client that saves its enrolled assets in local storage can skip attestation going forward. As the intent is that clients attest at boot time, this is a problem. One can deal with this problem by ensuring that clients run only trusted code that wouldn't do that. NOTE: It may be desirable to develop an attestation protocol for frequent attestation. Such a protocol wouldn't deliver enrolled assets to the client, ensuring only that the client continues to be in a trusted state. Such a protocol is out of scope for this document at this time.","title":"Analysis"},{"location":"protocol/#possible-improvements","text":"@osresearch proposes that we can use a policy to make sure that enrolled assets delivered to an attestation client cannot be decrypted unless the client attested to trusted state. We could do this using TPM2_PolicySigned() with a public key whose private key the attestation server possesses. The attestation client would then not be able to decrypt any of its enrolled encrypted assets without first getting a signature from the attestation server, which signature the attestation server would not provide unless it were happy with the client's attested state. The signature would be part of the response payload wrapper in a TPM2_MakeCredential() bound to the client's AK that has stClear . A key benefit of this approach is that the enrolled assets database would no longer be read-sensitive. We can get a stronger guarantee that the client's attested state is not spoofed by attaching a policy to the client's AK that binds the attested state, though this is racy (since the attested state can change during the attestation process, though in early boot it wouldn't). A client could avoid the race by starting and satisfying a corresponding policy session before engaging in the attestation protocol. With the current protocol the binding of attested state to the client's ability to \"activate\" the attestation server's response is only this: that the client must have access to the AK it used and that that AK must have fixedTPM | fixedParent | stClear | sign as its attributes. Associating a policy with the AK that uses TPM2_PolicyPCR() and TPM2_PolicyCounterTimer() to bind all the attested state would leave just one item unbound: the nonce (really, timestamp). We could use the nonce as a password to satisfy an authValue , using TPM2_PolicySecret() . Thus we could get a much stronger binding of the attested state to the client's ability to activat the attestation response. That said, the current, weaker, binding that we have in the protocol seems sufficient for our current purposes. Consider having attestation update some state on the server side for detection of resetCount going backwards (replay detection), and replay detection more generally when we start performing proof-of-possession and frequent re-attestation. Because we prize availability, we may use an eventually-consistent method of sharing mutable attestation state on the server side.","title":"Possible Improvements"},{"location":"protocol/#securing-communications-with-tpms","text":"Depending on the threat model it is essential to use encryption sessions to encrypt sensitive command/response parameters, and to authenticate all commands and responses. Authentication of communications with a TPM depends on the application knowing the TPM's EKpub . Sadly, it is not commonly the case that a computer's BIOS knows the computer's TPM's EKpub from factory. As a result, it is possible for invasive, physical MITM attacks on TPMs. Once a device's TPM's EKpub is enrolled, any MITM has to be in the middle every time the attestation client runs. Therefore the MITM has to have been in the middle from the moment the device is enrolled.","title":"Securing Communications with TPMs"},{"location":"protocol/#configuring-trust-anchors","text":"Attestation clients configured to use secure boot can find a locally configured trust anchor on local storage after successful decryption with a rootfs key. The rootfs key can be decrypted without authenticating its signature because if it can decrypt the local filesystem then the rootfs key must not have been altered by any attacker. Attestation clients that are not configured to use secure boot can find a locally configured trust anchor on local storage, or in a TPM \"non-volatile (NV) index\" (in the case of a TPM NV index, probably only a hash of the trust anchor would be stored in the NV index). In any case, authentication key rotation would be difficult. Indirection via intermediate keys (PKI-style) would help.","title":"Configuring Trust Anchors"},{"location":"protocol/#ekpub-validation","text":"We rely utterly on TPMs enforcing extended policies. This means that we must know that some EKpub is indeed a TPM's EKpub .","title":"EKpub Validation"},{"location":"protocol/#external-ekpub-validation-google-compute-environment","text":"In the Google Compute Environment the Google Shielded VM product allows us to lookup a device by name and obtain its EKpub in PEM format. If authorized users of the enrollment service can be trusted to fetch the EKpub from the Google Shielded VM API, then the enrollment server need not validate the EKpub at all -- the attestation server can just trust the given EKpub .","title":"External EKpub Validation (Google Compute Environment)"},{"location":"protocol/#ekpub-validation-using-ek-certificates","text":"When enrolling bare-metal hardware, as opposed to Google Shielded VMs, we must either extract the to-be-enrolled device's TPM's EKpub manually, and once more trust and allow only authorized users of the enrollment service to enroll those, or we must extract the to-be-enrolled device's TPM's EKcert and enroll that so that the enrollment server may validate the client's EKcert is issued by a trusted TPM vendor. XXX We have yet to implement this.","title":"EKpub Validation using EK Certificates"},{"location":"protocol/#alternatives-to-ekpubs","text":"Any primary key object with the fixedTPM , fixedParent , and decrypt attributes set is suitable as an substitute for the EKpub provided that the process of calling TPM2_CreatePrimary() and reading its public key is secured by using the EKpub , and that the legitimacy of the TPM is established. Wherever we refer to an EKpub in this document, one may substitute such an alternative key.","title":"Alternatives to EKpubs"},{"location":"protocol/#appendix-a-symmetric-aead-cipher-mode-confounded-aes-256-cbc-hmac-sha-256","text":"For bulk encryption we use AES-256 with an authenticated encryption with additional data (AEAD) cipher mode. Given our implementation constraints we ended up using a cipher mode based on the well-understood Kerberos cryptosystem specified in RFCs 3962 and 8009 . Kerberos uses AES with the CipherText Stealing (CTS) cipher mode, confounded, and with an HMAC with a SHA family digest. CTS is a variation of Cipher Block Chaining mode (CBC). The differences between our confounded AES-256-CBC-HMAC-SHA-256 and the Kerberos cipher modes are: we use CBC instead of CTS we use SHA-256 with AES-256 we don't truncate the HMAC NOTE: Well, we could use SHA-384 with AES-256 for the HMAC, but then again, we're not truncating the HMAC. NOTE: \"Confounding\" consists of prepending to the plaintext a cipherblock's worth (16 bytes) of randomly generated bits. This causes the ciphertext resulting from the encryption of the \"confounder\" to function as the actual, non-zero IV for the plaintext. Confounded CBC is indistinguishable from CBC with explicit IV, except that it costs one more cipher block operation, so it is slightly slower. NOTE: CTS is a variation of CBC that does not require padding. It does not work for plaintexts shorter than a cipher block (16 bytes), but since confounding means prefixing a cipher block's worth of nonce to the plaintext, confounded CTS always expands the plaintext by just one cipher block's worth, and does not require padding. Therefore a plaintext that is 30 bytes will yield a ciphertext that is 46 bytes (+ 32 more bytes for the HMAC), a 31 byte plaintext will yield a 47 byte ciphertext, etc. Replacing CTS with CBC does not enable any further cryptanalysis since, after all, CTS applied to plaintexts of length divisible by the cipher's block size is equivalent to CBC. NOTE: When we switch to using OpenSSL 3.0 we will be able to use CTS instead of CBC. NOTE: The primary reason for using this construction is that it is easily implemented in Bash with OpenSSL 1.x tooling, and OpenSSL 1.x tooling does not provide authenticated encryption constructions in its command-line tools that are suitable for encrypting data at rest. To encrypt a secret the enrollment server: creates a random AES-256 key uses confounded AES-256-CBC-HMAC-SHA-256: a. uses AES-256 in cipher block chaining (CBC) mode with all-zero IV confounding (a cipherblock's worth of entropy prepended to the plaintext) padding b. appends an HMAC-SHA-256 digest of the resulting ciphertext The padding is per-OpenSSL (if the plaintext is a whole multiple of 16 bytes then 16 bytes of zeros are added, else as many bytes are appended to bring the plaintext size to a whole multiple of 16 bytes, with the last byte set to the count of padding bytes). The resulting ciphertexts are stored as-is in the enrollment DB. The per-secret AES-256 keys are encrypted to the device's TPM's EKpub, and to the escrow agents. Decryption of confounded AES-256-CBC-HMAC-SHA-256 ciphertexts is as follows: compute the HMAC-SHA-256 MAC of the ciphertext (excluding the MAC in the ciphertext) constant-time compare the computed MAC to the MAC in the ciphertext if these do not match, fail decrypt the ciphertext (excluding the MAC) with AES-256 in CBC mode discard the first block of the resulting plaintext (the confounder) examine the last byte of the plaintext and drop the indicated amount of padding","title":"Appendix A: Symmetric AEAD Cipher Mode: Confounded AES-256-CBC-HMAC-SHA-256"},{"location":"safeboot/","text":"Safe Boot subcommands Usage: safeboot subcommand [options...] key-init Usage: safeboot key-init \"subject\" Generate a new x509 signing key with openssl, writing storing the public key in /etc/safeboot/cert.pem and the password protected private key in /etc/safeboot/signing.key . This is not as secure as storing it in a hardware token, although if the key is moved to an external device and the $KEY variable in /etc/safeboot/local.conf updated to point to it, then it will prevent a software-only attack. The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/ yubikey-init Usage: safeboot yubikey-init \"subject\" Generate a new x509 signing key on an attached Yubikey device and set the certificate subject to the provided argument. The public key certificate will be written to /etc/safeboot/cert.pem and will also be used for the UEFI SecureBoot variables. Due to a limitation in the OpenSSL PKCS11 engine, you have to enter the password multiple times (once for the engine, and then once for the signature). The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/ yubikey-pubkey Usage: safeboot yubikey-pubkey cert.pem Extract the public key certificate in PEM, DER and PUB format. The sbsign tool wants PEM, the kmodsign tool wants DER, the tpm2-tools wants a raw public key. The best part about standards... uefi-sign-keys Usage: safeboot uefi-sign-keys Create three signed certificates for the PK, KEK, and db using the attached Yubikey or x509 key stored in /etc/safeboot/signing.key and store them in the UEFI SecureBoot configuration. You should have run safeboot yubikey-init or safeboot key-init to have already generated the keys. Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate to the Yubikey multiple times during this process. uefi-set-keys Usage: safeboot uefi-set-keys Store the PK, KEK, and db into the UEFI Secure Boot configuration variables. This must be done once during system setup or if a new key is generated. The uefi-sign-key subcommand attempts to do this automatically. pcrs-sign Usage: safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel] Generate a signature for the PCRs that can be used to unseal the LUKS key according to the policy created by safeboot luks-seal . The PCRs used are specified in the /etc/safeboot/safeboot.conf or local.conf files, and must match the values that were configured during luks-seal . If the prevent-rollback argument is prevent-rollback , the TPM version counter will be incremented, which will invalidate all previous PCR signatures and prevent the older unified kernel images from being able to unseal the PCR data. The signature is persisted in a UEFI NVRAM variable, defined in safeboot.conf . luks-seal Usage: safeboot luks-seal This will generate a new LUKS encryption key for the block device in /etc/crypttab and requires an existing recovery key to install the new key slot. You will also be prompted for an unlock PIN, which will be required on the next normal boot in place of the recovery code. If this is the first time the disk has been sealed, /etc/crypttab will be updated to include a call to the unsealing script to retrieve the keys from the TPM, and a counter will be created to prevent rollbacks. After sealing the secret, the initrd will be rebuild, the kernel signed, and the new predicted PCRs signed. Any previous sealed data will be invalidated since the version counter will be incremented. Right now only a single crypt disk is supported. sign Usage: safeboot sign exe [exe.signed] Sign an EFI executable with the safeboot keys. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead. unify-kernel Usage: safeboot unify-kernel linux.efi kernel=path-to-kernel initrd=path-to-initrd ... Creates a unified kernel image with the named sections and files (typically kernel , initrd , cmdline , and osrel ) bundled into an EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry. sign-kernel Usage: safeboot sign-kernel linux.efi [linux.signed.efi] Sign a unified EFI executable with the safeboot keys. If no destination is specified it will be the same name as the input kernel with .signed.efi added. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry. install-kernel Usage: safeboot install-kernel boot-name [extra kernel parameters...] Create an EFI boot menu entry for boot-name , with the specified kernel, initrd and command line bundled into an executable and signed. This command requires the Yubikey or x509 password to be able to sign the merged EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead. linux-sign Usage: safeboot linux-sign [target-name [parameters...]] Generate dm-verity hashes and then sign the Linux with the root hash added to the kernel command line. The default target for the EFI boot manager is linux . You will need the Yubikey or x509 password to sign the new hashes and kernel. If the environment variable $HASH is set to the hash value, or if the $HASHFILE variable points to the previous dmverity log (typically /boot/efi/EFI/linux/verity.log ), then the precomputed value will be used instead of recomputing the dmverity hashes (which can take some time). If the hashes are out-of-date, this might render the linux target unbootable and require a recovery reboot to re-hash the root filesystem. recovery-sign Usage: safeboot recovery-sign [kernel command line...] Sign the Linux kernel and initrd into the EFI boot manager recovery entry. Typically this only needs to be done once and after validating that the system can boot with it, you should not have to re-run this command. You will need the Yubikey or x509 password as well as root accesss to perform this action. If SIP is enabled the root device will be marked read-only for the reboot and fscked will not been run on boot. Use safeboot remount to remount / as read-write when in recovery mode, and then safeboot remount ro to restore it to read-only mode before signing the hashes. recovery-reboot Usage: safeboot recovery-reboot Configure the EFI boot manager so that the BootNext is the recovery target and reboot the machine. This command requires root access to update the EFI variables and will also require the disk encryption recovery key since the TPM will not unseal the disk automatically for recovery mode. NOTE! This will reboot the machine! bootnext Usage: safeboot bootnext Setup Configure the EFI boot manager BootNext variable to select an alternate boot menu item. This command requires root access to update the EFI variables. remount Usage: safeboot remount [ro] Attempt to remount the root filesystem read/write or read-only. If SIP is enabled this will likely invalidate any hashes and require a re-signing of the root filesystem. If ro is specified, then the file system will be re-mounted read-only If there are processes blocking the remount, they will be listed. sip-init Usage: safeboot sip-init [home-size-in-GB [var-size]] DANGER! This command can mess up your root filesystem. There must be space in the volume group for the new entries It will create the volume groups for /var and /home , add entries to /etc/fstab for them with secure mount parameters, and makes /tmp a symlink into /var/tmp . unlock Usage: safeboot unlock This is a recovery shell command to scan the /etc/crypttab for devices and call cryptsetup luksOpen on each of them, and then scan the LVM groups for volumes. After it succeeds you can call safeboot mount to mount the root filesystem (read-only) on /root . mount-all Usage: safeboot mount-all This is a recovery shell command to attempt to mount the root disk read-only on /root , as well as the /boot and /boot/efi if they exist in /root/etc/fstab .","title":"safeboot subcommands"},{"location":"safeboot/#safe-boot-subcommands","text":"Usage: safeboot subcommand [options...]","title":"Safe Boot subcommands"},{"location":"safeboot/#key-init","text":"Usage: safeboot key-init \"subject\" Generate a new x509 signing key with openssl, writing storing the public key in /etc/safeboot/cert.pem and the password protected private key in /etc/safeboot/signing.key . This is not as secure as storing it in a hardware token, although if the key is moved to an external device and the $KEY variable in /etc/safeboot/local.conf updated to point to it, then it will prevent a software-only attack. The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/","title":"key-init"},{"location":"safeboot/#yubikey-init","text":"Usage: safeboot yubikey-init \"subject\" Generate a new x509 signing key on an attached Yubikey device and set the certificate subject to the provided argument. The public key certificate will be written to /etc/safeboot/cert.pem and will also be used for the UEFI SecureBoot variables. Due to a limitation in the OpenSSL PKCS11 engine, you have to enter the password multiple times (once for the engine, and then once for the signature). The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/","title":"yubikey-init"},{"location":"safeboot/#yubikey-pubkey","text":"Usage: safeboot yubikey-pubkey cert.pem Extract the public key certificate in PEM, DER and PUB format. The sbsign tool wants PEM, the kmodsign tool wants DER, the tpm2-tools wants a raw public key. The best part about standards...","title":"yubikey-pubkey"},{"location":"safeboot/#uefi-sign-keys","text":"Usage: safeboot uefi-sign-keys Create three signed certificates for the PK, KEK, and db using the attached Yubikey or x509 key stored in /etc/safeboot/signing.key and store them in the UEFI SecureBoot configuration. You should have run safeboot yubikey-init or safeboot key-init to have already generated the keys. Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate to the Yubikey multiple times during this process.","title":"uefi-sign-keys"},{"location":"safeboot/#uefi-set-keys","text":"Usage: safeboot uefi-set-keys Store the PK, KEK, and db into the UEFI Secure Boot configuration variables. This must be done once during system setup or if a new key is generated. The uefi-sign-key subcommand attempts to do this automatically.","title":"uefi-set-keys"},{"location":"safeboot/#pcrs-sign","text":"Usage: safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel] Generate a signature for the PCRs that can be used to unseal the LUKS key according to the policy created by safeboot luks-seal . The PCRs used are specified in the /etc/safeboot/safeboot.conf or local.conf files, and must match the values that were configured during luks-seal . If the prevent-rollback argument is prevent-rollback , the TPM version counter will be incremented, which will invalidate all previous PCR signatures and prevent the older unified kernel images from being able to unseal the PCR data. The signature is persisted in a UEFI NVRAM variable, defined in safeboot.conf .","title":"pcrs-sign"},{"location":"safeboot/#luks-seal","text":"Usage: safeboot luks-seal This will generate a new LUKS encryption key for the block device in /etc/crypttab and requires an existing recovery key to install the new key slot. You will also be prompted for an unlock PIN, which will be required on the next normal boot in place of the recovery code. If this is the first time the disk has been sealed, /etc/crypttab will be updated to include a call to the unsealing script to retrieve the keys from the TPM, and a counter will be created to prevent rollbacks. After sealing the secret, the initrd will be rebuild, the kernel signed, and the new predicted PCRs signed. Any previous sealed data will be invalidated since the version counter will be incremented. Right now only a single crypt disk is supported.","title":"luks-seal"},{"location":"safeboot/#sign","text":"Usage: safeboot sign exe [exe.signed] Sign an EFI executable with the safeboot keys. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead.","title":"sign"},{"location":"safeboot/#unify-kernel","text":"Usage: safeboot unify-kernel linux.efi kernel=path-to-kernel initrd=path-to-initrd ... Creates a unified kernel image with the named sections and files (typically kernel , initrd , cmdline , and osrel ) bundled into an EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry.","title":"unify-kernel"},{"location":"safeboot/#sign-kernel","text":"Usage: safeboot sign-kernel linux.efi [linux.signed.efi] Sign a unified EFI executable with the safeboot keys. If no destination is specified it will be the same name as the input kernel with .signed.efi added. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry.","title":"sign-kernel"},{"location":"safeboot/#install-kernel","text":"Usage: safeboot install-kernel boot-name [extra kernel parameters...] Create an EFI boot menu entry for boot-name , with the specified kernel, initrd and command line bundled into an executable and signed. This command requires the Yubikey or x509 password to be able to sign the merged EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead.","title":"install-kernel"},{"location":"safeboot/#linux-sign","text":"Usage: safeboot linux-sign [target-name [parameters...]] Generate dm-verity hashes and then sign the Linux with the root hash added to the kernel command line. The default target for the EFI boot manager is linux . You will need the Yubikey or x509 password to sign the new hashes and kernel. If the environment variable $HASH is set to the hash value, or if the $HASHFILE variable points to the previous dmverity log (typically /boot/efi/EFI/linux/verity.log ), then the precomputed value will be used instead of recomputing the dmverity hashes (which can take some time). If the hashes are out-of-date, this might render the linux target unbootable and require a recovery reboot to re-hash the root filesystem.","title":"linux-sign"},{"location":"safeboot/#recovery-sign","text":"Usage: safeboot recovery-sign [kernel command line...] Sign the Linux kernel and initrd into the EFI boot manager recovery entry. Typically this only needs to be done once and after validating that the system can boot with it, you should not have to re-run this command. You will need the Yubikey or x509 password as well as root accesss to perform this action. If SIP is enabled the root device will be marked read-only for the reboot and fscked will not been run on boot. Use safeboot remount to remount / as read-write when in recovery mode, and then safeboot remount ro to restore it to read-only mode before signing the hashes.","title":"recovery-sign"},{"location":"safeboot/#recovery-reboot","text":"Usage: safeboot recovery-reboot Configure the EFI boot manager so that the BootNext is the recovery target and reboot the machine. This command requires root access to update the EFI variables and will also require the disk encryption recovery key since the TPM will not unseal the disk automatically for recovery mode. NOTE! This will reboot the machine!","title":"recovery-reboot"},{"location":"safeboot/#bootnext","text":"Usage: safeboot bootnext Setup Configure the EFI boot manager BootNext variable to select an alternate boot menu item. This command requires root access to update the EFI variables.","title":"bootnext"},{"location":"safeboot/#remount","text":"Usage: safeboot remount [ro] Attempt to remount the root filesystem read/write or read-only. If SIP is enabled this will likely invalidate any hashes and require a re-signing of the root filesystem. If ro is specified, then the file system will be re-mounted read-only If there are processes blocking the remount, they will be listed.","title":"remount"},{"location":"safeboot/#sip-init","text":"Usage: safeboot sip-init [home-size-in-GB [var-size]] DANGER! This command can mess up your root filesystem. There must be space in the volume group for the new entries It will create the volume groups for /var and /home , add entries to /etc/fstab for them with secure mount parameters, and makes /tmp a symlink into /var/tmp .","title":"sip-init"},{"location":"safeboot/#unlock","text":"Usage: safeboot unlock This is a recovery shell command to scan the /etc/crypttab for devices and call cryptsetup luksOpen on each of them, and then scan the LVM groups for volumes. After it succeeds you can call safeboot mount to mount the root filesystem (read-only) on /root .","title":"unlock"},{"location":"safeboot/#mount-all","text":"Usage: safeboot mount-all This is a recovery shell command to attempt to mount the root disk read-only on /root , as well as the /boot and /boot/efi if they exist in /root/etc/fstab .","title":"mount-all"},{"location":"threats/","text":"safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. The protections offered by UEFI Secure Boot fall short of these goals in several areas. The default signing keys in Secure Boot are not under control of the computer owner -- the bootloader root CA keys are controlled by Microsoft, who signs the keys used to sign the shim bootloader, which has the Linux distribution keys built in. Owners can enroll their keys to the Machine Owner Key (MOK), but this does not replace the distribution keys in the shim. Even with SecureBoot enabled, most distributions still go through grub for a boot menu, which increases the attack surface and adds another layer of validation that needs to be done. Finally, Canonical signs the kernel and the kernel modules so that they are accepted by the shim and grub, but the initrd is unsigned and an attacker can replace it without too much difficulty since it is stored in plaintext on the disk. Additionally, none of the Linux distributions support TPM protected keys out of the box, which is why it is necessary to install a package like safeboot to make use of them. Protections The protections that are applied by the /usr/sbin/safeboot script and setup instructions include: Firmware Enabling UEFI Secure Boot, Supervisor password, Tamper Switches, etc Generating an owner controlled signing key in a hardware token Installing the owner's signing key as the UEFI Secure Boot Platform Key ( PK ) Removing OEM and Microsoft keys from the UEFI Secure Boot key database ( db ) Signing the kernel, initrd and command line with the owner's hardware key Booting LUKS block device encryption on / , /home , /var and swap. TPM Sealing the disk encryption key with the UEFI firmware and configuration values The TPM sealed secret can be protected with a PIN The TPM sealed secret can be protected from rollback with a TPM counter If unsealing fails, attesting to the firmware state with TOTP and using a recovery key Storing the unsealed key in a protected kernel keyring and logging Enabling intel_iommu=on and efi=disable_early_pci_dma to eliminate some hardware attacks Runtime Enabling lockdown=confidentiality mode to prevent root from accessing keyrings or memory Mounting the root filesystem read-only and marking the block device read-only Enabling dmverity hash checking on the root filesystem (\"SIP\" mode) Mounting /tmp , /home and /var with nosuid,nodev Removing Canonical's module signing key Adding usb-storage and other external media to the kernel module deny list Proving the firmware and kernel configuration to remote attestation servers with tpm2-attest Todo TODO: Flush encryption keys during sleep TODO: VPN config TODO: Prevent network reconfiguration TODO: Device VM separation TODO: Separate /home encryption TODO: Multiparty signatures for higher assurance TODO: Allowed list of USB device IDs. The behaviour of things like the tamper switches and supervisor password are as observed on the Lenovo X1 firmware (and some were fixed after reporting vulnerabilities to Lenovo); other devices may vary and have less secure behaviour. Attacks These changes protect against many local physical and software attacks. Physical hardware attacks A local attacker with physical access to the device can open the device to gain access to the drive, the SPI flash on the mainboard, the Management Engine and CPU chipset, the discrete TPM device, the RAM chips, PCIe buses (such as m.2 slots), etc. Opening the case to modify the flash or modify devices will trip the case tamper switch and prevent the device from booting until the firmware supervisor password is entered. This detects several classes of \"evil maid\" attacks that require physical access. Removing the disk to attempt to rewrite it or image it for offline attacks will trigger both the case tamper switch and the disk tamper switch. The firmware supervisor password is required to reboot, which will allow the user or administrator to detect that the device has been compromised. On Lenovo's recent firmware, the supervisor password is not stored in the SPI flash (Serial Peripheral Interface), but in the Embedded Controler (EC), and changing it requires the EC to validate the change. This prevents a local attacker from modifying the NVRAM variabels in the SPI flash to bypass the supervisor checks. However, the EC is an open field of security research. On Lenovo's recent firmware, the tamper switch state is stored in the EC, rather than the RTC RAM. This makes it more difficult to bypass the tamper switches since an EC or Bootguard attack is necessary. Exploits against the ME are unlikely to be detectable, although they require a level of expertise to pull off and do not provide persistence. A local attacker could use this to bypass Bootguard and other TPM provided protections. If they also know the TPM PIN and /home encryption password, they can exfiltrate data, but are unlikely to be able to gain persistence without the attack device in place due to the signed dmverity hashes. Changing the firmware in the SPI flash should be detected by Intel Bootguard's verification of the IBB during boot up and result in the device not booting. There are public TOCTOU attacks against Bootguard, so a local attacker can bypass the measured root of trust to boot their unsigned firmware and kernel. As with the ME attacks, if the TPM PIN and /home encryption key are known then data can be exfiltrated, but this does not provide persistence. Writing new platform keys in the SPI flash will result in a TPM unsealing failure since the UEFI secure boot configuration is part of the measured state included in the TPM PCRs. An attack that presents a fake recovery key input dialog can be detected by the tpm2-totp tool. The TPM2 will only generate the 30-second, 6-digit authentication code if the PCRs match the expected value and the administrator can verify it against their authenticator app. With TPM2, the HMAC is computed in the TPM itself, so the secret is never accessible to the operating system. The PCR values in the TPM are not \"secret\", so an adversary with physical access could directly wire to the TPM and provide it with the correct measurements to extend the PCRs to match the signed values. The user PIN is still necessary to unseal the secret and the TPM dictionary attack protections both rate-limit and retry-limit the attacker. Discrete TPM tampering on the LPC bus is not necessarily detectable by this system; an adversary with unlimited internal physical access can also probe sealed secrets. If a TPM PIN is used then the secrets might be brute-forcable, but would require much longer internal access. Functional TPM tampering is out of scope since the fTPM is an application running inside the Intel Management Engine, not a separate device, and the ME is the root of all trust in the system. An adversary with code execution on the ME is able to bypass all of the other platform protections (with maybe the exception of SGX enclaves, although this is not certain). In a \"Coldboot\" attacks on the memory , an attack triggers a reboot in order to boot into their own kernel that doesn't clear memory. Since most of the old contents are still present, this custom kernel can read through memory to look for secrets. This attack is prevented by requiring valid owner signatures on any kernel, and could be additionally prevented by enabling Intel TXT with an enforced DRAM clear, although a physically proximate attacker can turn off those protections by modifying the NVRAM variables during the boot process. In another variant of the coldboot attack, the attacker freezes the RAM chips with cooling spray, removes the physical memory modules and install them into a new system that the attacker controls and that is configured to not clear the memory on power up. This attack is not easily doable on the X1 since all of the RAM is soldered onto mainboard, but is possible against part of the memory on the T490 since it has some of its memory soldered and some on a DIMM. TODO: Can Linux restrict the keys to the hard soldered chips? The encryption keys are stored in RAM even while the system is asleep, which makes the keys potentially available to an attacker with certain resources; it would be worthwhile to consider flushing them prior to entering S3 suspend. This would require modifying the init scripts that handle resume to prompt for the password; the TPM sealed encryption keys are problematic since the TPM state is reloaded during a resume. Physical software attacks Modifying the unencrypted kernel or initrd on /boot or attempting to pass in unapproved kernel command line parameters is prevented by the UEFI Secure Boot signature checks. The firmware will not hand control of the system to an unsigned EFI executable, which in this case is the entire kernel, initrd, and command line. This prevents both physical rewriting the disk in another machine, as well as if an attacker escallates to root and remounts /boot as read-write. The boot order NVRAM variable could be modified by an attacker with access to the SPI flash or if they have escallated to root. However, booting from an external device still requires an EFI executable signed by the PK/KEK/db, and since the default signing keys (typically the OEM and Microsoft) have been removed, only images signed the the computer owner's key will be booted from the external USB flash drive. Adversaries might try to gain persistence or weaken security by gaining write access to the unencrypted /boot partition and changing the kernel images. This requires either a root escalation or a tamper switch bypass, but the firmware will deny them peristence by refusing to boot from the modified image since the signature is checked when they are loaded into RAM at boot. There should not be any runtime TOCTOU since the DRAM has been initialized and there is space to store the entire image prior to validating the signature. The adversary might roll back to a prior version of the signed kernel and initrd, with a prior signed version of the PCRs. This is prevented by using monotonic TPM counter in addition to the signature. When a security critical update is available, the TPM counter is incremented and the PCRs are signed with that new value. The TPM will refuse to unseal older sealed data since the counter no longer matches. The TPM counter should be protected against rollback since deleting and re-creating a counter does not reset it to zero, but instead to the highest value that any counter in the TPM has ever reached. Adversaries might try to gain persistence by gaining write access to the encrypted and dmverity protected / filesystem, which requires a kernel escalation since dmverity prohibits writes to the protected block device, or a tamper switch bypass in addition to possession of the TPM disk unsealing keys. However, even with write access, the adversary can not gain persistence since the signed kernel command line and signed initrd enable dmverity hash checking, which will detect any modifications to / . They would also need access to the signing keys to be able to produce a new valid root hash. An adversary might try to gain run time access to the disk encryption key. The PCRs are extended with the booted state so that the TPM will no longer unseal it after the initrd, and root is prevented from reading the key from the Linux kernel keyring, so a kernel escallation is required to gain access to it. TODO: qubes style separate VM for disk and user? Some of the ports on the device, such as Thunderbolt and PCIe, have the ability to DMA in and out of main memory, which would allow a local attacker to connect a device that reads secrets out of unencrypted memory. The safeboot kernel commandline parameter configuration turns on the Intel IOMMU by default, as well as turns off PCIe bus-mastering, both of which should protect against attacks like Thunderspy as well as some classes of malicious devices on the Thunderbolt port or internal Mini-PCIe ports. Software attacks An attacker might try to exfiltrate data by plugging in a USB flash drive, which is prevented by adding usb-storage to the deny list. The USB ports could also be turned off in the UEFI Setup , although this would also prevent external keyboards and mice, if they are desired. An attacker with root access could try to load the USB storage module with insmod /lib/modules/..../usb-storage.ko , which bypasses the /etc/modprobe.d/ configuration. This can be prevented by removing the module from the root filesystem. An attacker with root access could download a version of the usb-storage module from the Ubuntu website, which is signed by the Canononical key and can be loaded into a stock kernel since their key is in the default key ring. This is prevented by building a custom kernel with a module signing key that is not stored on the machine. An attacker with root access could try to kexec into a custom kernel that doesn't overwrite the disk encryption key and that doesn't enforce external device access. This is prevented by the Linux kernel lockdown mode (turned on by UEFI Secure Boot mode) , which requires a signature on the new kernel by one of the keys in the UEFI Secure Boot key database, which only contains the public key of the hardware token used to sign the real kernel and initrd. An attacker with root access could try to bypass the module or kexec signature checks by opening /dev/mem or otherwise directly poking into memory to enable the hardware to escalate into kernel mode. The Lockdown patches also disable access to the memory device and prevent root from being able to adjust iopl or other special modes, which should make it more difficult for an attacker to escalate into kernel mode. An attacker with root access might try to use the Linux kernel keyring to read the disk encryption key. This is prevented by enabling lockdown=confidentiality mode , which prevent all kernel memory accesses from user space, and also ensures that the keyrings are not accessible. The attacker would require an additional privilege escalation is required to turn off lockdown. An attacker might try to escalate to root by somehow creating device files or mounting filesystems with SUID binaries. The /etc/fstab entries for /home and /var are configured to not allow such executables. TODO: Prevent network reconfiguration that bypasses mandatory VPN. TODO: ensure that the magic sysctl isn't allowed to bypass various security bits. Todo TODO: rollback attacks; how to use TPM counters to prevent them TODO: Document rebuilding the kernel TODO: configure allow/deny lists to clean up the module directories. TODO: SELinux config TODO: qubes/secureview separation TODO: /home encryption TODO: TPM PIN TODO: tpm-totp TODO: document how tpm2-attest handles access to remote resources","title":"Threat Model"},{"location":"threats/#protections","text":"The protections that are applied by the /usr/sbin/safeboot script and setup instructions include:","title":"Protections"},{"location":"threats/#firmware","text":"Enabling UEFI Secure Boot, Supervisor password, Tamper Switches, etc Generating an owner controlled signing key in a hardware token Installing the owner's signing key as the UEFI Secure Boot Platform Key ( PK ) Removing OEM and Microsoft keys from the UEFI Secure Boot key database ( db ) Signing the kernel, initrd and command line with the owner's hardware key","title":"Firmware"},{"location":"threats/#booting","text":"LUKS block device encryption on / , /home , /var and swap. TPM Sealing the disk encryption key with the UEFI firmware and configuration values The TPM sealed secret can be protected with a PIN The TPM sealed secret can be protected from rollback with a TPM counter If unsealing fails, attesting to the firmware state with TOTP and using a recovery key Storing the unsealed key in a protected kernel keyring and logging Enabling intel_iommu=on and efi=disable_early_pci_dma to eliminate some hardware attacks","title":"Booting"},{"location":"threats/#runtime","text":"Enabling lockdown=confidentiality mode to prevent root from accessing keyrings or memory Mounting the root filesystem read-only and marking the block device read-only Enabling dmverity hash checking on the root filesystem (\"SIP\" mode) Mounting /tmp , /home and /var with nosuid,nodev Removing Canonical's module signing key Adding usb-storage and other external media to the kernel module deny list Proving the firmware and kernel configuration to remote attestation servers with tpm2-attest","title":"Runtime"},{"location":"threats/#todo","text":"TODO: Flush encryption keys during sleep TODO: VPN config TODO: Prevent network reconfiguration TODO: Device VM separation TODO: Separate /home encryption TODO: Multiparty signatures for higher assurance TODO: Allowed list of USB device IDs. The behaviour of things like the tamper switches and supervisor password are as observed on the Lenovo X1 firmware (and some were fixed after reporting vulnerabilities to Lenovo); other devices may vary and have less secure behaviour.","title":"Todo"},{"location":"threats/#attacks","text":"These changes protect against many local physical and software attacks.","title":"Attacks"},{"location":"threats/#physical-hardware-attacks","text":"A local attacker with physical access to the device can open the device to gain access to the drive, the SPI flash on the mainboard, the Management Engine and CPU chipset, the discrete TPM device, the RAM chips, PCIe buses (such as m.2 slots), etc. Opening the case to modify the flash or modify devices will trip the case tamper switch and prevent the device from booting until the firmware supervisor password is entered. This detects several classes of \"evil maid\" attacks that require physical access. Removing the disk to attempt to rewrite it or image it for offline attacks will trigger both the case tamper switch and the disk tamper switch. The firmware supervisor password is required to reboot, which will allow the user or administrator to detect that the device has been compromised. On Lenovo's recent firmware, the supervisor password is not stored in the SPI flash (Serial Peripheral Interface), but in the Embedded Controler (EC), and changing it requires the EC to validate the change. This prevents a local attacker from modifying the NVRAM variabels in the SPI flash to bypass the supervisor checks. However, the EC is an open field of security research. On Lenovo's recent firmware, the tamper switch state is stored in the EC, rather than the RTC RAM. This makes it more difficult to bypass the tamper switches since an EC or Bootguard attack is necessary. Exploits against the ME are unlikely to be detectable, although they require a level of expertise to pull off and do not provide persistence. A local attacker could use this to bypass Bootguard and other TPM provided protections. If they also know the TPM PIN and /home encryption password, they can exfiltrate data, but are unlikely to be able to gain persistence without the attack device in place due to the signed dmverity hashes. Changing the firmware in the SPI flash should be detected by Intel Bootguard's verification of the IBB during boot up and result in the device not booting. There are public TOCTOU attacks against Bootguard, so a local attacker can bypass the measured root of trust to boot their unsigned firmware and kernel. As with the ME attacks, if the TPM PIN and /home encryption key are known then data can be exfiltrated, but this does not provide persistence. Writing new platform keys in the SPI flash will result in a TPM unsealing failure since the UEFI secure boot configuration is part of the measured state included in the TPM PCRs. An attack that presents a fake recovery key input dialog can be detected by the tpm2-totp tool. The TPM2 will only generate the 30-second, 6-digit authentication code if the PCRs match the expected value and the administrator can verify it against their authenticator app. With TPM2, the HMAC is computed in the TPM itself, so the secret is never accessible to the operating system. The PCR values in the TPM are not \"secret\", so an adversary with physical access could directly wire to the TPM and provide it with the correct measurements to extend the PCRs to match the signed values. The user PIN is still necessary to unseal the secret and the TPM dictionary attack protections both rate-limit and retry-limit the attacker. Discrete TPM tampering on the LPC bus is not necessarily detectable by this system; an adversary with unlimited internal physical access can also probe sealed secrets. If a TPM PIN is used then the secrets might be brute-forcable, but would require much longer internal access. Functional TPM tampering is out of scope since the fTPM is an application running inside the Intel Management Engine, not a separate device, and the ME is the root of all trust in the system. An adversary with code execution on the ME is able to bypass all of the other platform protections (with maybe the exception of SGX enclaves, although this is not certain). In a \"Coldboot\" attacks on the memory , an attack triggers a reboot in order to boot into their own kernel that doesn't clear memory. Since most of the old contents are still present, this custom kernel can read through memory to look for secrets. This attack is prevented by requiring valid owner signatures on any kernel, and could be additionally prevented by enabling Intel TXT with an enforced DRAM clear, although a physically proximate attacker can turn off those protections by modifying the NVRAM variables during the boot process. In another variant of the coldboot attack, the attacker freezes the RAM chips with cooling spray, removes the physical memory modules and install them into a new system that the attacker controls and that is configured to not clear the memory on power up. This attack is not easily doable on the X1 since all of the RAM is soldered onto mainboard, but is possible against part of the memory on the T490 since it has some of its memory soldered and some on a DIMM. TODO: Can Linux restrict the keys to the hard soldered chips? The encryption keys are stored in RAM even while the system is asleep, which makes the keys potentially available to an attacker with certain resources; it would be worthwhile to consider flushing them prior to entering S3 suspend. This would require modifying the init scripts that handle resume to prompt for the password; the TPM sealed encryption keys are problematic since the TPM state is reloaded during a resume.","title":"Physical hardware attacks"},{"location":"threats/#physical-software-attacks","text":"Modifying the unencrypted kernel or initrd on /boot or attempting to pass in unapproved kernel command line parameters is prevented by the UEFI Secure Boot signature checks. The firmware will not hand control of the system to an unsigned EFI executable, which in this case is the entire kernel, initrd, and command line. This prevents both physical rewriting the disk in another machine, as well as if an attacker escallates to root and remounts /boot as read-write. The boot order NVRAM variable could be modified by an attacker with access to the SPI flash or if they have escallated to root. However, booting from an external device still requires an EFI executable signed by the PK/KEK/db, and since the default signing keys (typically the OEM and Microsoft) have been removed, only images signed the the computer owner's key will be booted from the external USB flash drive. Adversaries might try to gain persistence or weaken security by gaining write access to the unencrypted /boot partition and changing the kernel images. This requires either a root escalation or a tamper switch bypass, but the firmware will deny them peristence by refusing to boot from the modified image since the signature is checked when they are loaded into RAM at boot. There should not be any runtime TOCTOU since the DRAM has been initialized and there is space to store the entire image prior to validating the signature. The adversary might roll back to a prior version of the signed kernel and initrd, with a prior signed version of the PCRs. This is prevented by using monotonic TPM counter in addition to the signature. When a security critical update is available, the TPM counter is incremented and the PCRs are signed with that new value. The TPM will refuse to unseal older sealed data since the counter no longer matches. The TPM counter should be protected against rollback since deleting and re-creating a counter does not reset it to zero, but instead to the highest value that any counter in the TPM has ever reached. Adversaries might try to gain persistence by gaining write access to the encrypted and dmverity protected / filesystem, which requires a kernel escalation since dmverity prohibits writes to the protected block device, or a tamper switch bypass in addition to possession of the TPM disk unsealing keys. However, even with write access, the adversary can not gain persistence since the signed kernel command line and signed initrd enable dmverity hash checking, which will detect any modifications to / . They would also need access to the signing keys to be able to produce a new valid root hash. An adversary might try to gain run time access to the disk encryption key. The PCRs are extended with the booted state so that the TPM will no longer unseal it after the initrd, and root is prevented from reading the key from the Linux kernel keyring, so a kernel escallation is required to gain access to it. TODO: qubes style separate VM for disk and user? Some of the ports on the device, such as Thunderbolt and PCIe, have the ability to DMA in and out of main memory, which would allow a local attacker to connect a device that reads secrets out of unencrypted memory. The safeboot kernel commandline parameter configuration turns on the Intel IOMMU by default, as well as turns off PCIe bus-mastering, both of which should protect against attacks like Thunderspy as well as some classes of malicious devices on the Thunderbolt port or internal Mini-PCIe ports.","title":"Physical software attacks"},{"location":"threats/#software-attacks","text":"An attacker might try to exfiltrate data by plugging in a USB flash drive, which is prevented by adding usb-storage to the deny list. The USB ports could also be turned off in the UEFI Setup , although this would also prevent external keyboards and mice, if they are desired. An attacker with root access could try to load the USB storage module with insmod /lib/modules/..../usb-storage.ko , which bypasses the /etc/modprobe.d/ configuration. This can be prevented by removing the module from the root filesystem. An attacker with root access could download a version of the usb-storage module from the Ubuntu website, which is signed by the Canononical key and can be loaded into a stock kernel since their key is in the default key ring. This is prevented by building a custom kernel with a module signing key that is not stored on the machine. An attacker with root access could try to kexec into a custom kernel that doesn't overwrite the disk encryption key and that doesn't enforce external device access. This is prevented by the Linux kernel lockdown mode (turned on by UEFI Secure Boot mode) , which requires a signature on the new kernel by one of the keys in the UEFI Secure Boot key database, which only contains the public key of the hardware token used to sign the real kernel and initrd. An attacker with root access could try to bypass the module or kexec signature checks by opening /dev/mem or otherwise directly poking into memory to enable the hardware to escalate into kernel mode. The Lockdown patches also disable access to the memory device and prevent root from being able to adjust iopl or other special modes, which should make it more difficult for an attacker to escalate into kernel mode. An attacker with root access might try to use the Linux kernel keyring to read the disk encryption key. This is prevented by enabling lockdown=confidentiality mode , which prevent all kernel memory accesses from user space, and also ensures that the keyrings are not accessible. The attacker would require an additional privilege escalation is required to turn off lockdown. An attacker might try to escalate to root by somehow creating device files or mounting filesystems with SUID binaries. The /etc/fstab entries for /home and /var are configured to not allow such executables. TODO: Prevent network reconfiguration that bypasses mandatory VPN. TODO: ensure that the magic sysctl isn't allowed to bypass various security bits.","title":"Software attacks"},{"location":"threats/#todo_1","text":"TODO: rollback attacks; how to use TPM counters to prevent them TODO: Document rebuilding the kernel TODO: configure allow/deny lists to clean up the module directories. TODO: SELinux config TODO: qubes/secureview separation TODO: /home encryption TODO: TPM PIN TODO: tpm-totp TODO: document how tpm2-attest handles access to remote resources","title":"Todo"},{"location":"tpm2-attest/","text":"tpm2-attest subcommands Usage: tpm2-attest subcommand [options...] For more information see: https://safeboot.dev/attestation/ quote Usage: tpm2-attest quote [nonce] > quote.tar scp quote.tar ... After contacting the remote attestation server to receive the nonce, the machine will generate the endorsement key, endorsement cert, a one-time attestation key, and a signed quote for the all PCRs using that nonce (or the time of day, if no nonce is supplied). The output quote.tar should be sent to the remote side for validation. There is nothing sensitive in the file, so it can be sent in clear text to the server. TODO: the quote should be integrity protected, although while it does not weaken the protocol, it does allow an adversary to create spurious attestation failures. attest Usage: tpm2-attest attest http://server/attest [nonce [pcrs,...]] > secret.txt This will generate a quote for the nonce (or the current time if none is specified) and for the PCRs listed in the $QUOTE_PCRS environment variable. It will then send the quote to a simple attestation server, which will validate the quote and reply with a sealed message that can only be decrypted by this TPM on this boot. No validation of the attestation server is done. verify Usage: tpm2-attest verify quote.tar [nonce [ca-path]] This will validate that the quote was signed with the attestation key with the provided nonce, and verify that the endorsement key from a valid TPM. It outputs, but does not validate the event log; use tpm2-attest eventlog-verify once the known PCRs are available, or use a more complex validation scheme. If the nonce is not specified, the one in the quote file will be used, although this opens up the possibility of a replay attack. The QUOTE_MAX_AGE can be used to ensure that the quote is fresh. If the ca-path is not specified, the system one will be used. The output on stdout is yaml formatted with the sha256 hash of the DER format EK certificate, the validated quote PCRs, and the unvalidated eventlog PCRs. eventlog Usage: tpm2-attest eventlog [eventlog.bin] This will read and parse the TPM2 eventlog. If no file is specified, the default Linux one will be parsed. If - is specified, the eventlog will be read from stdin. eventlog-verify Usage: tpm2-attest eventlog-verify quote.tar [good-pcrs.txt] This will verify that the PCRs included in the quote match the TPM event log, and if good-prcs.txt are passed in that they match those as well. ek-verify Usage: tpm2-attest ek-verify quote.tar ca-path This will validate that the endorsement key came from a valid TPM. The TPM endorsement key is signed by the manufacturer OEM key, which is in turn signed by a trusted root CA. Before trusting an attestation it is necessary to validate this chain of signatures to ensure that it came from a legitimate TPM, otherwise an attacker could send a quote that has a fake key and decrypt the message in software. The ca-path should contain a file named roots.pem with the trusted root keys and have the hash symlinks created by c_rehash . stdout is the sha256 hash of the DER format EK certificate. quote-verify Usage: tpm2-attest quote-verify quote.tar [nonce] This command checks that the quote includes the given nonce and was signed by the public attestation key (AK) in the quote file. This also check the attributes of the AK to ensure that it has the correct bits set ( fixedtpm , stclear , etc). NOTE: This does not verify that the AK came from a valid TPM. See tpm2-attest verify for the full validation. If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. stdout is the yaml formatted tpm2 checkquote , which can be used to validate the eventlog PCRs. seal Usage: echo secret | tpm2-attest seal quote.tar > cipher.bin After a attested quote has been validated, an encrypted reply is sent to the machine with a sealed secret, which can be of arbitrary length, that is encrypted with a random key. This random key is encrypted with that machines endorsment key ( ek.crt ), along with the name of the attestation key used to sign the quote. The TPM will not decrypt the message key unless the attestation key was one that it generated. The sealed.tar file should be sent back to the device being attested; it can then run tpm2-attest unseal < sealed.tar > secret.txt to extract the sealed secret (which may be of arbitrary length). unseal Usage: cat sealed.tar | tpm2-attest unseal > secret.txt When the remote attestation has been successful, the remote machine will reply with an encrypted blob that is only unsealable by this TPM if and only if the EK matches and the AK is one that it generated. verify-and-seal Usage: tpm2-attest verify-and-seal quote.tar [nonce [pcrs]] < secret.txt > sealed.tar If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. ek-sign Usage: tpm2-attest ek-sign < ek.pem > ek.crt [/CN=device-name/] Some TPMs do not include manufacturer signed endorsement key certificates, so it is necessary to extract the EK and sign it with a trusted key. This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. For Google Cloud ShieldedVM machines see: https://cloud.google.com/security/shielded-cloud/retrieving-endorsement-key Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! # on the device tpm2-attest ek-crt > ek.pem # on the server tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ # on the device again tpm2-attest ek-crt ek.crt ek-crt Usage: tpm2-attest ek-crt > ek.pem # Export the TPM EK in PEM format (not cert) or tpm2-attest ek-crt ek.crt # Import a signed cert for the EK in DER format Export the TPM RSA endorsement key for signing by a CA or import a signed endorsement key certificate into the TPM NVRAM at the well-known handle. See tpm2-attest ek-sign for more details.","title":"tpm2-attest subcommands"},{"location":"tpm2-attest/#tpm2-attest-subcommands","text":"Usage: tpm2-attest subcommand [options...] For more information see: https://safeboot.dev/attestation/","title":"tpm2-attest subcommands"},{"location":"tpm2-attest/#quote","text":"Usage: tpm2-attest quote [nonce] > quote.tar scp quote.tar ... After contacting the remote attestation server to receive the nonce, the machine will generate the endorsement key, endorsement cert, a one-time attestation key, and a signed quote for the all PCRs using that nonce (or the time of day, if no nonce is supplied). The output quote.tar should be sent to the remote side for validation. There is nothing sensitive in the file, so it can be sent in clear text to the server. TODO: the quote should be integrity protected, although while it does not weaken the protocol, it does allow an adversary to create spurious attestation failures.","title":"quote"},{"location":"tpm2-attest/#attest","text":"Usage: tpm2-attest attest http://server/attest [nonce [pcrs,...]] > secret.txt This will generate a quote for the nonce (or the current time if none is specified) and for the PCRs listed in the $QUOTE_PCRS environment variable. It will then send the quote to a simple attestation server, which will validate the quote and reply with a sealed message that can only be decrypted by this TPM on this boot. No validation of the attestation server is done.","title":"attest"},{"location":"tpm2-attest/#verify","text":"Usage: tpm2-attest verify quote.tar [nonce [ca-path]] This will validate that the quote was signed with the attestation key with the provided nonce, and verify that the endorsement key from a valid TPM. It outputs, but does not validate the event log; use tpm2-attest eventlog-verify once the known PCRs are available, or use a more complex validation scheme. If the nonce is not specified, the one in the quote file will be used, although this opens up the possibility of a replay attack. The QUOTE_MAX_AGE can be used to ensure that the quote is fresh. If the ca-path is not specified, the system one will be used. The output on stdout is yaml formatted with the sha256 hash of the DER format EK certificate, the validated quote PCRs, and the unvalidated eventlog PCRs.","title":"verify"},{"location":"tpm2-attest/#eventlog","text":"Usage: tpm2-attest eventlog [eventlog.bin] This will read and parse the TPM2 eventlog. If no file is specified, the default Linux one will be parsed. If - is specified, the eventlog will be read from stdin.","title":"eventlog"},{"location":"tpm2-attest/#eventlog-verify","text":"Usage: tpm2-attest eventlog-verify quote.tar [good-pcrs.txt] This will verify that the PCRs included in the quote match the TPM event log, and if good-prcs.txt are passed in that they match those as well.","title":"eventlog-verify"},{"location":"tpm2-attest/#ek-verify","text":"Usage: tpm2-attest ek-verify quote.tar ca-path This will validate that the endorsement key came from a valid TPM. The TPM endorsement key is signed by the manufacturer OEM key, which is in turn signed by a trusted root CA. Before trusting an attestation it is necessary to validate this chain of signatures to ensure that it came from a legitimate TPM, otherwise an attacker could send a quote that has a fake key and decrypt the message in software. The ca-path should contain a file named roots.pem with the trusted root keys and have the hash symlinks created by c_rehash . stdout is the sha256 hash of the DER format EK certificate.","title":"ek-verify"},{"location":"tpm2-attest/#quote-verify","text":"Usage: tpm2-attest quote-verify quote.tar [nonce] This command checks that the quote includes the given nonce and was signed by the public attestation key (AK) in the quote file. This also check the attributes of the AK to ensure that it has the correct bits set ( fixedtpm , stclear , etc). NOTE: This does not verify that the AK came from a valid TPM. See tpm2-attest verify for the full validation. If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. stdout is the yaml formatted tpm2 checkquote , which can be used to validate the eventlog PCRs.","title":"quote-verify"},{"location":"tpm2-attest/#seal","text":"Usage: echo secret | tpm2-attest seal quote.tar > cipher.bin After a attested quote has been validated, an encrypted reply is sent to the machine with a sealed secret, which can be of arbitrary length, that is encrypted with a random key. This random key is encrypted with that machines endorsment key ( ek.crt ), along with the name of the attestation key used to sign the quote. The TPM will not decrypt the message key unless the attestation key was one that it generated. The sealed.tar file should be sent back to the device being attested; it can then run tpm2-attest unseal < sealed.tar > secret.txt to extract the sealed secret (which may be of arbitrary length).","title":"seal"},{"location":"tpm2-attest/#unseal","text":"Usage: cat sealed.tar | tpm2-attest unseal > secret.txt When the remote attestation has been successful, the remote machine will reply with an encrypted blob that is only unsealable by this TPM if and only if the EK matches and the AK is one that it generated.","title":"unseal"},{"location":"tpm2-attest/#verify-and-seal","text":"Usage: tpm2-attest verify-and-seal quote.tar [nonce [pcrs]] < secret.txt > sealed.tar If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live.","title":"verify-and-seal"},{"location":"tpm2-attest/#ek-sign","text":"Usage: tpm2-attest ek-sign < ek.pem > ek.crt [/CN=device-name/] Some TPMs do not include manufacturer signed endorsement key certificates, so it is necessary to extract the EK and sign it with a trusted key. This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. For Google Cloud ShieldedVM machines see: https://cloud.google.com/security/shielded-cloud/retrieving-endorsement-key Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! # on the device tpm2-attest ek-crt > ek.pem # on the server tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ # on the device again tpm2-attest ek-crt ek.crt","title":"ek-sign"},{"location":"tpm2-attest/#ek-crt","text":"Usage: tpm2-attest ek-crt > ek.pem # Export the TPM EK in PEM format (not cert) or tpm2-attest ek-crt ek.crt # Import a signed cert for the EK in DER format Export the TPM RSA endorsement key for signing by a CA or import a signed endorsement key certificate into the TPM NVRAM at the well-known handle. See tpm2-attest ek-sign for more details.","title":"ek-crt"}]}