#!/bin/bash
# Safer Booting with UEFI Secure Boot and the TPM
#
# Be careful with this, it is possible to lock yourself
# out of your computer if you lose the firmware password
# and platform signing keys.
#
# For more details: https://safeboot.dev/
#
# turn off "expressions don't expand in single quotes"
# and "can't follow non-constant sources"
# shellcheck disable=SC2016 disable=SC1091
set -e -o pipefail
export LC_ALL=C

: "${PREFIX:=}"
: "${DIR:=/etc/safeboot}"

# shellcheck source=functions.sh
. "$PREFIX$DIR/functions.sh"

if [ -r "$PREFIX$DIR/safeboot.conf" ]; then
	# shellcheck source=safeboot.conf
	. $PREFIX$DIR/safeboot.conf
fi
if [ -r "$PREFIX$DIR/local.conf" ]; then
	# shellcheck source=local.conf
	. $PREFIX$DIR/local.conf
fi

# Apply $PREFIX to files and use default value
CERT=$PREFIX${CERT:-$DIR/cert.pem}
KERNEL=$PREFIX${KERNEL:-/boot/vmlinuz}
INITRD=$PREFIX${INITRD:-/boot/initrd.img}
EFIDIR=$PREFIX${EFIDIR:-/boot/efi/EFI}

if [ "$KEY" == "pkcs11:" ]; then
	# KEY is a hardware token, use the yubikey engine
	KEY_ENGINE="-e pkcs11"
else
	# KEY is a normal file, don't use an openssl engine
	KEY=$PREFIX${KEY:-$DIR/cert.priv}
	KEY_ENGINE=""
fi

# Set the default values for the other parameters
# Do not assign ROOTDEV or HASHDEV; they will be detected in rootdev-check
: "${ROOTDEV:=}"
: "${HASHDEV:=}"
: "${LINUX_TARGET:=linux}"
: "${RECOVERY_TARGET:=recovery}"
: "${SIP:=0}"
: "${PCRS:=0,2,5,7}"
: "${BOOTMODE_PCR:=14}"
: "${LINUX_COMMANDLINE:=}"
: "${RECOVERY_COMMANDLINE:=${LINUX_COMMANDLINE}}"
: "${SEAL_PIN:=1}"

#
# Ensure that there is a valid root device
#
rootdev-check()
{
	if [ -z "${ROOTDEV}" ]; then
		ROOTDEV="$(mount | awk '/ on \/ / { print $1 }')"
		warn "\$ROOTDEV is not set. Guessing $ROOTDEV"
		TEST_ROOTDEV=1
	fi

	if [ ! -e "$ROOTDEV" ]; then
		die "$ROOTDEV: root device does not exist?"
	fi

	if [ ! -r "$ROOTDEV" ]; then
		die "$ROOTDEV: root device permission denied"
	fi

	if [ "$TEST_ROOTDEV" = 1 ]; then
		warn "$PREFXI$DIR/local.conf: setting \$ROOTDEV=$ROOTDEV"
		echo "ROOTDEV=\"$ROOTDEV\"" >> $PREFIX$DIR/local.conf \
		|| die "$PREFIX$DIR/local.conf: Unable to set \$ROOTDEV"
		TEST_ROOTDEV=0
	fi

	if [ "$SIP" != 1 ]; then
		return 0
	fi

	if [ -z "$HASHDEV" ]; then
		HASHDEV="${ROOTDEV%-*}-hashes"
		warn "\$HASHDEV is not set. Guessing $HASHDEV (same volume group as \$ROOTDEV)"
		TEST_HASHDEV=1
	fi

	if [ ! -e "$HASHDEV" ]; then
		die "$HASHDEV: hash device does not exist. Please set in $PREFIX$DIR/local.conf"
	fi

	if [ ! -r "$HASHDEV" ]; then
		die "$HASHDEV: hash device permission denied. Please set in $PREFIX$DIR/local.conf"
	fi

	if [ "$TEST_HASHDEV" = 1 ]; then
		warn "$PREFXI$DIR/local.conf: setting \$HASHDEV=$HASHDEV"
		echo "HASHDEV=\"$HASHDEV\"" >> $PREFIX$DIR/local.conf \
		|| die "$PREFIX$DIR/local.conf: Unable to set \$HASHDEV"
		TEST_HASHDEV=0
	fi
}


usage='
# Safe Boot subcommands

Usage: `safeboot subcommand [options...]`

'

commands="commands"

commands() {
	echo "$usage"
	exit 0
}

show_help() {
	if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
		echo "$2"
		exit 0
	fi
}

########################################

key_init_usage='
## key-init
Usage:
```
safeboot key-init "subject"
```

Generate a new x509 signing key with openssl, writing storing
the public key in `/etc/safeboot/cert.pem` and the password
protected private key in `/etc/safeboot/signing.key`.
This is not as secure as storing it in a hardware token,
although if the key is moved to an external device and the
`$KEY` variable in `/etc/safeboot/local.conf` updated to point
to it, then it will prevent a software-only attack.

The subject must be written as a "distinguished name":
```
       /CN=host.example.com/OU=test/O=example.com/
```
'
usage+=$key_init_usage

key-init() {
	show_help "$1" "$key_init_usage"
	if [ $# == 0 ]; then
		die "$key_init_usage"
	fi

	subject=$1

	if [ "$KEY" == "pkcs11:" ]; then
		warn "\$KEY=pkcs11:; updating in local.conf"
		( \
		echo "# Added by key-init" ; \
		echo "KEY=$DIR/signing.key" ; \
		) >> "$PREFIX$DIR/local.conf" \
		|| die "Unable to update safeboot.conf"
		KEY="$PREFIX$DIR/signing.key"
	fi
	if [ -r "$KEY" ]; then
		read -r -p "WARNING: This will erase the existing key $KEY. Are you sure? " really_do_it
		if [ "$really_do_it" != "y" ]; then
			die "Not overwriting existing key"
		fi

		warn "$KEY: backing up to $KEY.orig"
	fi

	mkdir -p "$(dirname "$KEY")" "$(dirname "$CERT")"

	if [ -r "$KEY" ]; then
		mv "$KEY" "$KEY.orig" \
		|| die "$KEY: unable to backup"
	fi
	if [ -r "$CERT" ]; then
		mv "$CERT" "$CERT.orig" \
		|| die "$CERT: unable to backup"
	fi

	openssl req \
		-new \
		-x509 \
		-newkey "rsa:2048" \
		-subj "$subject" \
		-keyout "$KEY" \
		-outform "PEM" \
		-out "$CERT" \
		-days "3650" \
		-sha256 \
	|| die "$KEY: unable to create"

	# Create a certificate and public key file from the PEM
	pem2der "$CERT"
}

########################################

pem2der()
{
	crt_file="${1/.pem/.crt}"
	pub_file="${1/.pem/.pub}"

	warn "$crt_file: Creating from $1"
	openssl x509 \
		-outform der \
		-in "$1" \
		-out "$crt_file" \
	|| die "$crt_file: Unable to create DER file from $1"

	warn "$pub_file: Creating from $1"
	openssl x509 \
		-in "$1" \
		-noout \
		-pubkey \
		-out "$pub_file" \
	|| die "$pub_file: Unable to create PUB file from $1"
}

yubikey_daemon() {
	if ! pidof pcscd >/dev/null ; then
		warn "Starting PCSCD for yubikey support"
		pcscd --foreground &
	fi
}

yubikey_init_usage='
## yubikey-init
Usage:
```
safeboot yubikey-init "subject"
```

Generate a new x509 signing key on an attached Yubikey device
and set the certificate subject to the provided argument.
The public key certificate will be written to `/etc/safeboot/cert.pem`
and will also be used for the UEFI SecureBoot variables.

Due to a limitation in the OpenSSL PKCS11 engine, you have to enter
the password multiple times (once for the engine, and then once for
the signature).

The subject must be written as a "distinguished name":
```
       /CN=host.example.com/OU=test/O=example.com/
```
'
usage+=$yubikey_init_usage
commands+="|yubikey-init"

yubikey-init() {
	show_help "$1" "$yubikey_init_usage"
	if [ $# == 0 ]; then
		die "$yubikey_init_usage"
	fi

	subject=$1

	if [ "$KEY" != "pkcs11:" ]; then
		warn "Adding KEY=pkcs11: to local.conf"
		( \
		echo '# Added by yubikey-init' ; \
		echo 'KEY="pkcs11:"' ; \
		) >> $PREFIX$DIR/local.conf \
		|| die "$PREFIX$DIR/local.conf: Unable to append"
		KEY="pkcs11:"
	fi

	if [ -r "$CERT" ]; then
		warn "WARNING! $CERT already exists; copying to $CERT.orig"
		mv "$CERT" "$CERT.orig" \
		|| die "$CERT: unable to make backup"
	fi

	read -r -p "WARNING: This will erase any existing key on the yubikey. Are you sure? " really_do_it
	if [ "$really_do_it" != "y" ]; then
		die "Not overwriting existing key"
	fi

	# will take a while and overwrite any existing private keys
	warn "Generating new key..."
	yubico-piv-tool \
		-s 9c \
		-a generate \
		-o "$TMP/pubkey.pem" \
	|| die "unable to generate new key"

	warn "Self-signing certificate"
	yubico-piv-tool \
		-s 9c \
		-a verify-pin \
		-a selfsign-certificate \
		-S "$subject" \
		-i "$TMP/pubkey.pem" \
		-o "$CERT" \
	|| die "Unable to self-sign certificate"

	warn "Importing self-signed certificate into key"
	yubico-piv-tool \
		-s 9c \
		-a import-certificate \
		-i "$CERT" \
	|| die "Unable to import certificate into key"

	pem2der "$CERT"

	yubico-piv-tool \
		-a status \
	|| die "Unable to retrieve key status"
}

########################################
yubikey_pubkey_usage='
## yubikey-pubkey
Usage:
```
safeboot yubikey-pubkey cert.pem
```

Extract the public key certificate in PEM, DER and PUB format.
The `sbsign` tool wants PEM, the `kmodsign` tool wants DER,
the `tpm2-tools` wants a raw public key.
The best part about standards...
'
usage+=$yubikey_pubkey_usage
commands+="|yubikey-pubkey"

yubikey-pubkey()
{
	show_help "$1" "$yubikey_pubkey_usage"
	pem="$1"

	if [ -z "$pem" ]; then
		die "$yubikey_pubkey_usage"
	fi

	warn "Extracting signing cert from yubikey"
	yubico-piv-tool \
		-s 9c \
		-a read-certificate \
		-o "$pem" \
	|| die "$pem: unable to read from yubikey"

	pem2der "$pem"
}


########################################

uefi_sign_keys_usage='
## uefi-sign-keys
Usage:
```
safeboot uefi-sign-keys
```

Create three signed certificates for the PK, KEK, and db using
the attached Yubikey or x509 key stored in `/etc/safeboot/signing.key`
and store them in the UEFI SecureBoot configuration.  You should
have run `safeboot yubikey-init` or `safeboot key-init` to have
already generated the keys.

Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate
to the Yubikey multiple times during this process.
'

usage+=$uefi_sign_keys_usage
commands+="|uefi-sign-keys"

uefi-sign-keys() {
	show_help "$1" "$uefi_sign_keys_usage"

	cert-to-efi-sig-list \
		-g "$(uuidgen)" \
		"$CERT" \
		"$TMP/cert.esl" \
	|| die "cert-to-efi-sig-list failed"

	## Cache the yubico pin since it will be used multiple times
	#read -s -p 'Yubikey login PIN: ' pin
	#echo

	# Use the sign-efi-sig-list from our build so that the
	# -e option exists
	for key in db KEK PK; do
		warn "Signing UEFI variable $key"
		sign-efi-sig-list.safeboot \
			$KEY_ENGINE \
			-k "$KEY" \
			-c "$CERT" \
			"$key" \
			"$TMP/cert.esl" \
			$PREFIX$DIR/$key.auth \
		|| die "$key: Signing failed"
	done

	uefi-set-keys ""
}

########################################

uefi_set_keys_usage='
## uefi-set-keys
Usage:
```
safeboot uefi-set-keys
```

Store the PK, KEK, and db into the UEFI Secure Boot configuration
variables.  This must be done once during system setup or if a new
key is generated.  The `uefi-sign-key` subcommand attempts to do
this automatically.
'

usage+=$uefi_set_keys_usage
commands+="|uefi-set-keys"

uefi-set-keys()
{
	show_help "$1" "$uefi_set_keys_usage"

	# The order of update must be from lowest to highest
	for key in db KEK PK; do
		if [ ! -r "$PREFIX$DIR/$key.auth" ]; then
			die "$PREFIX$DIR/$key.auth not found: run safeboot uefi-sign-keys"
		fi

		warn "Installing UEFI variable $key"

		efi-updatevar -f "$PREFIX$DIR/$key.auth" "$key" \
		|| die "$key: updating key failed; is the BIOS in setup mode?"
	done
}


########################################

pcrs_sign_usage='
## pcrs-sign
Usage:
safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel]

Generate a signature for the PCRs that can be used to unseal the LUKS key
according to the policy created by `safeboot luks-seal`.  The PCRs used
are specified in the `/etc/safeboot/safeboot.conf` or `local.conf` files, and
must match the values that were configured during `luks-seal`.

If the prevent-rollback argument is `prevent-rollback`, the TPM version counter
will be incremented, which will invalidate all previous PCR signatures and prevent
the older unified kernel images from being able to unseal the PCR data.

The signature is persisted in a UEFI NVRAM variable, defined in `safeboot.conf`.
'
usage+="$pcrs_sign_usage"
commands+="|pcrs-sign"

pcrs-sign() {
	show_help "$1" "$pcrs_sign_usage"

	prevent_rollback="${1}"
	target="${2-linux}"
	linux="$EFIDIR/$target/linux.efi"

	yubikey_daemon

	if [ "$prevent_rollback" = "prevent-rollback" ]; then
		warn "$linux: Incrementing TPM version to prevent rollback"
		tpm2 nvincrement \
			"$TPM_NV_VERSION" \
			>> /tmp/tpm.log \
		|| die "Unable to increment TPM version $TPM_NV_VERSION"
	fi

	tpm2 nvread \
		"$TPM_NV_VERSION" \
		> "$TMP/nv_version.bin" \
	|| die "Unable to read TPM version $TPM_NV_VERSION"
	VERSION="$(xxd -g8 "$TMP/nv_version.bin" | awk '{print $2}')"
	warn "$linux: TPM version $VERSION"

	# If pre-computed PCRs are known, they can be used here instead
	# TODO: allow PCRs to be passed in
	tpm2 pcrread -o "$TMP/pcrs.bin" "sha256:$PCRS" \
	|| die "Unable to read TPM PCRs"

	# Check to see if the PCR4 matches the expected value
	# for the Linux kernel (which will be loaded as the boot application).
	# This works on the Thinkpad X1, which extends PCR4
	# with EFI_EV_SEPARATOR and then the PE hash of the EFI_BOOT_APPLICATION
	linux_hash="$(sbsign.safeboot --hash-only "$linux" || die "unable to hash")"
	ev_sep="$(echo "00000000" | hex2bin | tpm2_trial_extend 0)"
	pcr4_computed="$(echo -n "${ev_sep}${linux_hash}" | hex2bin | sha256)"

	pcr2_read="$(tpm2 pcrread sha256:2 | tail -1 | cut -c9- | tr '[:upper:]' '[:lower:]')"
	pcr4_read="$(tpm2 pcrread sha256:4 | tail -1 | cut -c9- | tr '[:upper:]' '[:lower:]')"

	# HACK: this assumes PCR2 is the second in the list
	if [ "$pcr2_read" != "$ev_sep" ]; then
		warn "PCR2: ignoring BootMenu entries"
		echo -n "$ev_sep" | hex2bin \
		| dd \
			of="$TMP/pcrs.bin" \
			conv=notrunc \
			seek=1 \
			bs=32 \
			2>/dev/null \
		|| die "$TPM/pcrs.bin: unable to update PCR2"
	fi

	warn "$linux: PE hash $linux_hash"

	if [ "$pcr4_computed" == "$pcr4_read" ]; then
		warn "PCR4 unchanged"
	else
		warn "PCR4 $pcr4_computed"

		# HACK: replace the PCR with the computed one, assuming PCR14 is the 3rd
		# initrd dd does not support iflag=fullblock status=none
		echo -n "$pcr4_computed" | hex2bin \
		| dd \
			of="$TMP/pcrs.bin" \
			conv=notrunc \
			seek=2 \
			bs=32 \
			2>/dev/null \
		|| die "$TPM/pcrs.bin: unable to update PCR4"
	fi

	# Add a "normal" entry for PCR 14, which ensures that the TPM
	# will only unseal during a normal boot, not a recovery boot.
	# the unseal script will also extend PCR14 after unsealing
	# to prevent the TPM from unsealing the secret a second time
	#
	# TODO: Fix the ordering if the boot mode PCR is not the last on the list
	pcr14="$(echo -n "${LINUX_TARGET}" | tpm2_trial_extend "$PCR_DEFAULT")"
	warn "mode=${LINUX_TARGET} PCR$BOOTMODE_PCR=$pcr14"
	echo -n "$pcr14" | hex2bin \
		>> "$TMP/pcrs.bin"
	echo "final PCRs:"
	xxd -g32 -c32 "$TMP/pcrs.bin" | awk '{print $2}'

	tpm2_create_policy "$TMP/pcrs.bin" "$VERSION"

	openssl dgst \
		-sha256 \
		-sign "$KEY" \
		${KEY_ENGINE:+ \
			-keyform engine \
			-engine pkcs11 \
		} \
		-out "$TMP/pcr.policy.sig" \
		"$TMP/pcr.policy" \
	|| die "Unable to sign PCR policy"

	efivar_write "$PCR_SIGNATURE" < "$TMP/pcr.policy.sig" \
	|| die "$PCR_SIGNATURE: Unable to write to EFI variable"
}


luks_seal_usage='
## luks-seal
Usage:
```
safeboot luks-seal
```

This will generate a new LUKS encryption key for the block device in
`/etc/crypttab` and requires an existing recovery key to install the
new key slot.  You will also be prompted for an unlock PIN, which will
be required on the next normal boot in place of the recovery code.

If this is the first time the disk has been sealed, `/etc/crypttab`
will be updated to include a call to the unsealing script to retrieve
the keys from the TPM, and a counter will be created to prevent rollbacks.

After sealing the secret, the initrd will be rebuild, the kernel signed,
and the new predicted PCRs signed.  Any previous sealed data will be
invalidated since the version counter will be incremented.

Right now only a single crypt disk is supported.

'

usage+=$luks_seal_usage
commands+="|luks-seal"

luks-seal() {
	show_help "$1" "$luks_seal_usage"

	if [ -n "$1" ]; then
		PCRS="$1"
		shift
	fi
	if [ -n "$1" ]; then
		BOOTMODE_PCR="$1"
		shift
	fi

	yubikey_daemon

	KEYSLOT=1

	# check to see if the initramfs hook is installed
	if [ ! -x "$PREFIX/etc/initramfs-tools/hooks/safeboot-hooks" ]; then
		warn "!!! $PREFIX/etc/initramfs-tools/hooks/safeboot-hooks is not installed; this will probably not work"
	fi

	# and make sure that the unlock script is installed as expected
	if [ ! -x "$PREFIX/usr/sbin/safeboot" ]; then
		warn "!!! $PREFIX/usr/sbin/safeboot is not installed; this will probably not work"
	fi

	if [ "$(wc -l < "$PREFIX/etc/crypttab")" -ne 1 ]; then
		die "!!! $PREFIX/etc/crypttab must have only one entry"
	fi

	# Determine which device is the cryptdisk
	uuid="$(cut -d' ' -f2 $PREFIX/etc/crypttab)"
	if [ -z "$uuid" ]; then
		die "Unable to find UUID in crypttab"
	fi
	dev=$(blkid -U "${uuid#UUID=}")
	if [ -z "$dev" ]; then
		die "Unable to find device for $uuid"
	fi

	# Use a tmpfs mount instead of just a temp directory so that
	# the disk encryption key doesn't touch a persistent disk.
	mount_tmp

	# The PCR contents are not important here, only the list of them.
	# The signed PCR values created by pcrs_sign will be used for unsealing
	# the contents, not these values
	# Ask for a PIN that will be used to decrypt, if configured
	if [ "$SEAL_PIN" = "1" ]; then
		while true; do
			read -r -s -p "New unsealing PIN: " SEAL_PIN1
			echo
			if [ "$SEAL_PIN1" = "" ]; then
				echo >&2 'PIN must not be empty, unset $SEAL_PIN in /etc/safeboot/local.conf instead'
				continue
			fi

			read -r -s -p "Unsealing PIN again: " SEAL_PIN2
			echo
			if [ "$SEAL_PIN1" = "$SEAL_PIN2" ]; then
				break
			fi
		done
	fi

	# Ensure that there is a TPM counter at the desired address
	tpm2 nvundefine \
		"$TPM_NV_VERSION" \
		>> /tmp/tpm.log \
	|| warn "Unable to remove old TPM counter $TPM_NV_VERSION"

	tpm2 nvdefine \
		"$TPM_NV_VERSION" \
		--attributes 'authread|authwrite|nt=counter' \
		--size 8 \
		>> /tmp/tpm.log \
	|| die "Unable to create TPM counter $TPM_NV_VERSION"

	tpm2 nvincrement \
		"$TPM_NV_VERSION" \
		>> /tmp/tpm.log \
	|| die "Unable to initialize TPM counter $TPM_NV_VERSION"

	tpm2_create_policy

	dd \
		if=/dev/urandom \
		of="$TMP/key.bin" \
		bs=32 \
		count=1 \
		iflag=fullblock \
		status=none \
		2>/dev/null \
	|| die "Unable to generate random key"

	warn "Sealing secret with TPM, storing sealed secret in $TPM_NV_VERSION"

	tpm2_flushall

	tpm2 createprimary \
		--key-context "$TMP/primary.ctx" \
		>> /tmp/tpm.log \
	|| die "Unable to create TPM primary object"

	tpm2 create \
		--parent-context "$TMP/primary.ctx" \
		--policy "$TMP/signed.policy" \
		--sealing-input "$TMP/key.bin" \
		${SEAL_PIN1:+ --key-auth "$SEAL_PIN1" } \
		--public "$TMP/sealed.pub" \
		--private "$TMP/sealed.priv" \
		>> /tmp/tpm.log \
	|| die "Unable to create TPM key context"

	tpm2 load \
		--parent-context "$TMP/primary.ctx" \
		--public "$TMP/sealed.pub" \
		--private "$TMP/sealed.priv" \
		--name "$TMP/sealed.name" \
		--key-context "$TMP/sealed.ctx" \
	|| die "Unable to load sealed object into TPM"

	tpm2 evictcontrol \
		--hierarchy owner \
		--object-context "$TPM_SEALED_HANDLE" \
	|| warn "Unable to evict existing sealed handle $TPM_SEALED_HANDLE, ignoring"

	tpm2 evictcontrol \
		--hierarchy owner \
		--object-context "$TMP/sealed.ctx" \
		"$TPM_SEALED_HANDLE" \
	|| die "Unable to persist sealed data into the TPM"

	# make sure the crypttab has the unlock script referenced
	if ! grep keyscript "$PREFIX/etc/crypttab" > /dev/null ; then
		warn "adding crypttab unseal script"
		sed \
			-i.orig \
			's: luks: keyscript=/usr/sbin/safeboot-tpm-unseal,luks:' \
			$PREFIX/etc/crypttab \
		|| die "$PREFIX/etc/crypttab: unable to add keyscript"

		need_update_initramfs=1
	fi

	# ask for the disk encryption key
	for tries in 1 2 3 fail; do
		read -r -s -p "$dev: Current recovery password: " recovery_key
		echo
		echo -n "$recovery_key" > "$TMP/recovery.key"

		warn "Removing old LUKS TPM key (if it exists)"
		cryptsetup luksKillSlot \
			--key-file "$TMP/recovery.key" \
			"$dev" $KEYSLOT \
		|| warn "$dev: Unable to remove old key slot (ignored)"

		warn "Adding new LUKS TPM key"
		cryptsetup luksAddKey \
			--key-file "$TMP/recovery.key" \
			--key-slot $KEYSLOT \
			"$dev" "$TMP/key.bin" \
		&& break

		warn "$dev: Unable to add key slot"

		if [ $tries == fail ]; then
			die "$dev: Unable to add key"
		fi
	done

	rm -f "$TMP/key.bin"

	warn "$dev: sealed with PCR $PCRS,$BOOTMODE_PCR"

	if [ -n "$need_update_initramfs" ]; then
		warn "-------- Need to update initramfs --------"
		update-initramfs -u \
		|| die "Unable to update initramfs"

		warn "-------- Need to sign new kernel --------"
		linux-sign "$LINUX_TARGET" \
		|| die "Unable to sign kernel"
	fi

	warn "-------- Need to sign PCR and counter values --------"
	pcrs-sign "allow-rollback" "$LINUX_TARGET" \
	|| die "Unable to sign PCRs"
}

########################################

sign_kernel_usage='
## sign-kernel
Usage:
```
safeboot sign-kernel boot-name [extra kernel parameters...]
```

Create an EFI boot menu entry for `boot-name`, with the specified
kernel, initrd and command line bundled into an executable and signed.
This command requires the Yubikey or x509 password to be able to sign
the merged EFI executable.

This is the raw command; you might want to use `safeboot linux-sign` or
`safeboot recovery-sign` instead.
'

usage+=$sign_kernel_usage
commands+="|sign-kernel"

sign-kernel() {
	show_help "$1" "$sign_kernel_usage"

	yubikey_daemon

	TARGET="$1" ; shift

	if [ -z "$TARGET" ]; then
		die "$sign_kernel_usage"
	fi

	OUTDIR="${EFIDIR}/${TARGET}"

	if [ ! -d "$OUTDIR" ]; then
		warn "$OUTDIR: Creating directory on EFI System Partition"
		mkdir -p "$OUTDIR" \
		|| die "$OUTDIR: unable to create"
	fi

	if ! efibootmgr | grep "^Boot.* $TARGET\$" ; then
		# determine the device the EFI system partition is on
		DEV="$(df "$OUTDIR" | tail -1 | cut -d' ' -f1)"

		warn "$OUTDIR: Creating boot menu item on $DEV"
		efibootmgr \
			--quiet \
			--create \
			--disk "$DEV" \
			--part 1 \
			--label "$TARGET" \
			--loader "\\EFI\\$TARGET\\linux.efi" \
		|| die "efibootmgr: failed to create $TARGET entry"
	fi

	if [ $# == 0 ]; then
		warn "Using /proc/cmdline"
		cat /proc/cmdline > "$TMP/cmdline.txt"
	else
		echo -n "$@" > "$TMP/cmdline.txt"
	fi

	echo "Kernel commandline: '$(cat "$TMP/cmdline.txt")'"

	warn "$TMP/linux.efi: Creating merged Linux/initrd image"
	objcopy \
		--add-section .osrel="$PREFIX/etc/os-release" \
		--add-section .cmdline="$TMP/cmdline.txt" \
		--add-section .linux="$KERNEL" \
		--add-section .initrd="$INITRD" \
		--change-section-vma .osrel=0x20000 \
		--change-section-vma .cmdline=0x30000 \
		--change-section-vma .linux=0x40000 \
		--change-section-vma .initrd=0x3000000 \
		"$PREFIX/usr/lib/systemd/boot/efi/linuxx64.efi.stub" \
		"$TMP/linux.efi" \
	|| die "linux.efi: unable to create"

	for try in 1 2 3 ; do
		warn "$OUTDIR/linux.efi: Signing (ignore warnings about gaps)"
		sbsign.safeboot \
			$KEY_ENGINE \
			--key "$KEY" \
			--cert "$CERT" \
			--output "$OUTDIR/linux.efi.new" \
			"$TMP/linux.efi" \
		&& break

		if [ "$try" == 3 ]; then
			die "$OUTDIR/linux.efi: failed after $try tries"
		fi

		warn "$OUTDIR/linux.efi: signature failed! Try $try."
	done

	# Duplicate the old image and atomically move the new kernel
	# image to avoid potentially leaving an unbootable system
	if [ -r "$OUTDIR/linux.efi" ]; then
		cp "$OUTDIR/linux.efi" "$OUTDIR/linux.efi.old" \
		|| die "$OUTDIR/linux.efi.old: unable to backup old image"
	fi

	mv "$OUTDIR/linux.efi.new" "$OUTDIR/linux.efi" \
	|| die "$OUTDIR/linux.efi: unable to install new image"

	sha256sum "$OUTDIR/linux.efi"

	if [ -r "$TMP/verity.log" ]; then
		# stash a copy of the verity log in the boot directory
		# so that repeat signing can be done more quickly
		cp "$TMP/verity.log" "$OUTDIR"
	fi
}

########################################

linux_sign_usage='
## linux-sign
Usage:
```
safeboot linux-sign [target-name [parameters...]]
```

Generate dm-verity hashes and then sign the Linux with the root hash added
to the kernel command line.  The default target for the EFI boot manager is
`linux`.  You will need the Yubikey or x509 password to sign the new hashes
and kernel.

If the environment variable `$HASH` is set to the hash value, or if
the `$HASHFILE` variable points to the previous dmverity log (typically
`/boot/efi/EFI/linux/verity.log`), then the precomputed value will be used
instead of recomputing the dmverity hashes (which can take some time).
If the hashes are out-of-date, this might render the `linux` target
unbootable and require a recovery reboot to re-hash the root filesystem.
'

usage+=$linux_sign_usage
commands+="|linux-sign"

linux-sign()
{
	show_help "$1" "$linux_sign_usage"
	rootdev-check -

	# default is linux
	if [ -n "$1" ]; then
		TARGET=$1
		shift
	else
		TARGET=${LINUX_TARGET}
	fi

	if [ "$SIP" == 1 ]; then
		if mount | grep "^${ROOTDEV} " >/dev/null ; then \
			remount_ro "$ROOTDEV" \
				|| die "${ROOTDEV}: Could not remount"
		fi

		if [ -n "$HASH" ]; then
			warn "$ROOTDEV: Using hash $HASH"
		elif [ -n "$HASHFILE" ]; then
			warn "$ROOTDEV: Using hash file $HASFILE"
			HASH="$(awk '/Root hash:/ { print $3 }' "$HASHFILE")"
		else
			echo "$ROOTDEV: Computing hashes: this will take a while..."
			veritysetup format \
				--debug \
				"${ROOTDEV}" \
				"${HASHDEV}" \
				| tee "$TMP/verity.log" \
			|| die "$ROOTDEV: unable to compute hashes"

			HASH="$(awk '/Root hash:/ { print $3 }' "$TMP/verity.log")"
		fi

		if [ -z "$HASH" ]; then
			die "$ROOTDEV: root hash not in log?"
		fi

		ROOT_ARGS="\
			root=/dev/mapper/vroot \
			fsck.mode=skip \
			verity.hashdev=${HASHDEV} \
			verity.rootdev=${ROOTDEV} \
			verity.hash=$HASH \
		"
	else
		warn "SIP mode is not enabled"
		ROOT_ARGS="\
			root=${ROOTDEV}
		"
	fi

	sign-kernel "$TARGET" \
		"$LINUX_COMMANDLINE" \
		"$ROOT_ARGS" \
		"safeboot.mode=$TARGET" \
		"$@" \
	|| die "Kernel signing failed!"
}

########################################

recovery_sign_usage='
## recovery-sign
Usage:
```
safeboot recovery-sign [kernel command line...]
```

Sign the Linux kernel and initrd into the EFI boot manager
`recovery` entry.  Typically this only needs to be done once
and after validating that the system can boot with it, you
should not have to re-run this command.

You will need the Yubikey or x509 password as well as root
accesss to perform this action.

If SIP is enabled the root device will be marked read-only
for the reboot and fscked will not been run on boot.

Use `safeboot remount` to remount `/` as read-write when
in recovery mode, and then `safeboot remount ro` to restore
it to read-only mode before signing the hashes.
'

usage+=$recovery_sign_usage
commands+="|recovery-sign"

recovery-sign()
{
	show_help "$1" "$recovery_sign_usage"
	rootdev-check -

	if [ "$SIP" == 1 ]; then
		# ensure that the root file system is really
		# read-only; otherwise it will corrupt the hashes
		ROOT_ARGS="blockdev.ro=${ROOTDEV} fsck=skip"
	else
		# allow the root filesystem to be rw, since
		# /var is probably not separated and services won't start
		ROOT_ARGS=""
	fi

	sign-kernel "${RECOVERY_TARGET}" \
		"$RECOVERY_COMMANDLINE" \
		"root=${ROOTDEV}" \
		"$ROOT_ARGS" \
		"safeboot.mode=$RECOVERY_TARGET" \
		"$@" \
	|| die "Kernel signing failed!"
}

reboot() {
	umount /boot/efi
	umount /boot
	mount -o ro,remount "$ROOTDEV"
	sync ; sync ; sync

	warn "Initiating reboot!"
	sleep 2
	sync ; sync ; sync

	if [ -x "/usr/bin/reboot" ]; then
		# busybox reboot, no init to go through
		exec /usr/bin/reboot -f
	fi
	if [ -x "/sbin/reboot" ]; then
		# normal reboot process
		exec /sbin/reboot
	fi
}

########################################

recovery_reboot_usage='
## recovery-reboot
Usage:
```
safeboot recovery-reboot
```

Configure the EFI boot manager so that the `BootNext` is the recovery
target and reboot the machine.  This command requires root access to
update the EFI variables and will also require the disk encryption
recovery key since the TPM will not unseal the disk automatically for
recovery mode.

**NOTE!** This will reboot the machine!
'

usage+=$recovery_reboot_usage
commands+="|recovery-reboot"

recovery-reboot()
{
	show_help "$1" "$recovery_reboot_usage"
	efi_bootnext "${RECOVERY_TARGET}" \
	|| die "${RECOVERY_TARGET}: unable to select for next boot"

	warn "Rebooting in 3 seconds"
	sleep 3
	reboot
}

bootnext_usage='
## bootnext
Usage:
```
safeboot bootnext Setup
```

Configure the EFI boot manager `BootNext` variable to select an
alternate boot menu item.  This command requires root access to
update the EFI variables.
'

usage+=$bootnext_usage
commands+="|bootnext"

bootnext()
{
	show_help "$1" "$bootnext_usage"
	efi_bootnext "${1:-recovery}"
}

########################################

# Remount a filesystem as read-only.
# If it fails, report which processes have write access or
# temporary deleted files still open.

remount_ro()
{
	rootdev-check -

	DEV="${1:-${ROOTDEV}}"
	KILLALL="$2"

	if [ "$(blockdev --getro "${DEV}")" == 1 ] ; then
		warn "${DEV}: already read-only"
		return 0
	fi

	# systemd often ends up holding an open file, so tell init
	# to reload its status
	telinit u

	warn "${DEV}: remounting read-only"
	if mount -o ro,noatime,remount "${DEV}" ; then

		warn "${DEV}: forcing fsck"
		fsck.ext4 -f "${DEV}" \
			|| die "${DEV}: Could not fsck"

		warn "${DEV}: setting block dev readonly"
		blockdev --setro "${DEV}" \
			|| die "${DEV}: Could not set read-only"

		return 0
	fi

	warn "${DEV}: something blocked remount. Likely processes:"
	lsof +f -- "${DEV}" 2>&- \
		| awk '$4 == "DEL" || $4 ~ /[0-9][uw]$/ { print $2, $1, $3, "("$4")" }' \
		| tee "$TMP/pid.lst" \
	|| warn "lsof failed"


	if [ "$KILLALL" = "killall" ]; then
		warn "KILLING ALL PROCESSES in 5 seconds"
		sleep 5
		awk '{print $1}' "$TMP/pid.lst" | xargs kill
	else
		warn "Re-run 'safeboot remount ro killall' to kill processes"
	fi

	return 1
}

remount_rw()
{
	rootdev-check -

	DEV="${1:-${ROOTDEV}}"

	warn "${DEV}: remounting read-write"

	blockdev --setrw "${DEV}" \
	|| die "${DEV}: Unable to mark as read-write"

	mount -o rw,remount "${DEV}" \
	|| die "${DEV}: Unable to remount read-write"

	if [ "$SIP" == 1 ]; then
		warn "${DEV}: Remounted read/write; remember to re-sign the root hashes before rebooting!"
	else
		warn "${DEV}: Remounted read/write"
	fi
}

########################################

remount_usage='
## remount
Usage:
```
safeboot remount [ro]
```

Attempt to remount the root filesystem read/write or read-only.
If SIP is enabled this will likely invalidate any hashes
and require a re-signing of the root filesystem.

If `ro` is specified, then the file system will be re-mounted read-only
If there are processes blocking the remount, they will be listed.
'

usage+=$remount_usage
commands+="|remount"

remount()
{
	show_help "$1" "$remount_usage"
	rootdev-check -
	RW="$1"
	shift

	if [ "$RW" == "ro" ]; then
		remount_ro "${ROOTDEV}" "$@"
	elif [ "$RW" == "rw" ] || [ "$RW" == "" ]; then
		remount_rw "${ROOTDEV}"
	else
		die "Unknown argument.$remount_usage"
	fi
}


########################################

sip_init_usage='
## sip-init
Usage:
```
safeboot sip-init [home-size-in-GB [var-size]]
```

**DANGER!** This command can mess up your root filesystem.
There must be space in the volume group for the new entries
It will create the volume groups for `/var` and `/home`,
add entries to `/etc/fstab` for them with secure mount parameters,
and makes `/tmp` a symlink into `/var/tmp`.
'

usage+=$sip_init_usage
commands+="|sip-init"

sip-init()
{
	show_help "$1" "$sip_init_usage"
	rootdev-check -

	var_size=${1:-16g}
	home_size=${2:-80g}

	warn "sip-init: Checking configuration before writing..."

	root_size="$(lvdisplay --units b "${ROOTDEV}" | awk '/LV Size/{print $3}')"
	vg="$(lvdisplay "${ROOTDEV}" | awk '/VG Name/{print $3}')"

	if [ -z "$vg" ]; then
		die "${ROOTDEV}: unknown volume group?"
	fi
	if [ -z "$root_size" ]; then
		die "${ROOTDEV}: unknown size"
	fi
	if [ "$root_size" -gt $((16*1024*1024*1024)) ]; then
		die "${ROOTDEV}: root is $root_size bytes, too large for hashes"
	fi

	# if the volume groups already exist, we don't want to overwrite them
	if [ -e "/dev/mapper/$vg-var" ]; then
		die "$vg-var already exists"
	fi
	if [ -e "/dev/mapper/$vg-home" ]; then
		die "$vg-home already exists"
	fi

	# or if they have entries in the fstab for /home or /var
	grep '\s/var\s' $PREFIX/etc/fstab >/dev/null && \
		die "/var already exists in $PREFIX/etc/fstab"
	grep '\s/home\s' $PREFIX/etc/fstab >/dev/null && \
		die "/home already exists in $PREFIX/etc/fstab"

	# make sure the signing cert exists
	if [ ! -r "$CERT" ]; then
		die "$CERT: signing certificate not available!"
	fi

	# and refuse to do this unless they already have a recovery image
	entry="$(efiboot-entry ${RECOVERY_TARGET})"
	if [ -z "$entry" ]; then
		die "No ${RECOVERY_TARGET} in efibootmgr? Too dangerous!"
	fi

	##### And now it gets really dangerous #####

	cat >&2 <<'EOF'
     _                             _
  __| | __ _ _ __   __ _  ___ _ __| |
 / _` |/ _` | '_ \ / _` |/ _ \ '__| |
| (_| | (_| | | | | (_| |  __/ |  |_|
 \__,_|\__,_|_| |_|\__, |\___|_|  (_)
===================|___/=============

This will make irrevocable changes to the disk!
You must have the security key or password for
the UEFI Platform Key to procede.

EOF
	read -r -p "Are you really really sure? " really_do_it
	if [ "$really_do_it" != "y" ]; then
		die "Not configuring SIP!"
	fi
	read -r -p "WARNING: Do you have the security key? " really_do_it
	if [ "$really_do_it" != "y" ]; then
		die "Not configuring SIP!"
	fi

	remount "rw" \
	|| die "Root file system is not writable"

	# shellcheck disable=SC2034
	die_msg="
********************************************************
***** THIS IS BAD: Your system might be broken now *****
********************************************************

Please contact the developers with a report of what happened.
You can try to look back through the log messages to see if
you can unwind the changes that were made.
"

	# create the volume groups
	lvcreate --size 1g -n hashes "$vg" \
	|| die "$vg-hashes: unable to create volume"

	lvcreate --size "$var_size" -n var "$vg" \
	|| die "$vg-var: unable to create volume"

	lvcreate --size "$home_size" -n home "$vg" \
	|| die "$vg-home: unable to create volume"

	# relocate /var and /home to the new volumes
	for lv in var home ; do
		mkfs.ext4 "/dev/mapper/$vg-$lv" \
		|| die "$vg-$lv: unable to make filesystem"

		warn "Adding /$lv to fstab"
		echo >> "$PREFIX/etc/fstab" \
			"/dev/mapper/$vg-$lv /$lv ext4 nosuid,nodev 0 1" \
		|| die "unable to add /$lv to fstab"

		mkdir -p "/tmp-$lv" \
		|| die "/tmp-$lv: unable to create temporary mount point"

		mount "/dev/mapper/$vg-$lv" "/tmp-$lv" \
		|| die "$vg-$lv: unable to mount temporary mount point"

		warn "Moving contents of /$lv to new filesystem"
		mv "/$lv/"* "/tmp-$lv/" \
		|| die "$vg-$lv: unable to move everything from old mount"

		umount "/tmp-$lv" \
		|| die "$vg-$lv: unable to unmount"

		mount "/$lv" \
		|| die "/$lv: unable to remount new file system"
	done

	# and fix up /tmp
	warn "/tmp: Creating new temporary directory"
	rm -rf /tmp \
	|| die "/tmp: unable to clean up"

	ln -sf ./var/tmp /tmp \
	|| die "/tmp: unable to create symlink"

	if [ "$SIP" != 1 ]; then
		warn "Adding SIP=1 to local.conf"
		( \
		echo "# Added by sip-init" ; \
		echo "SIP=1" ; \
		) >> "$PREFIX$DIR/local.conf" \
		|| die "$PREFIX$DIR/safeboot.conf: unable to enable SIP?"
	fi

	if [ -z "$HASHDEV" ]; then
		HASHDEV="/dev/mapper/$vg-hashes"
		warn "$PREFIX$DIR/local.conf: adding HASHDEV=$HASHDEV"
		echo "HASHDEV=\"$HASHDEV\"" >> "$PREFIX$DIR/local.conf" \
		|| die "$PREFIX$DIR/local.conf: unable to add HASHDEV"
	fi

	warn "${ROOTDEV}: now configured for SIP hashed on ${HASHDEV}, but not yet signed!"
	warn "${ROOTDEV}: reboot and immediately run 'safeboot linux-sign'"
}

########################################

unlock_usage='
## unlock
Usage:
```
safeboot unlock
```

This is a recovery shell command to scan the `/etc/crypttab` for devices
and call `cryptsetup luksOpen` on each of them, and then scan the LVM groups
for volumes.  After it succeeds you can call `safeboot mount` to mount
the root filesystem (read-only) on `/root`.
'

usage+=$unlock_usage
commands+="|unlock"

unlock_entry() {
	cryptsetup luksOpen \
		"$(resolve_device_spec "$CRYPTTAB_SOURCE")" \
		"$CRYPTTAB_NAME"
}

unlock() {
	. /lib/cryptsetup/functions

	TABFILE=/cryptroot/crypttab \
	crypttab_foreach_entry unlock_entry \
	|| die "unable to unlock every encrypted disk"

	lvm pvscan
	lvm vgscan
	lvm lvscan
}

mount_all_usage='
## mount-all
Usage:
```
safeboot mount-all
```

This is a recovery shell command to attempt to mount the root disk read-only
on `/root`, as well as the `/boot` and `/boot/efi` if they exist in
`/root/etc/fstab`.
'
usage+=$mount_all_usage
commands+="|mount-all"

mount-all() {
	mkdir -p /root

	warn "$ROOTDEV: setting to read-only"
	blockdev --setro "$ROOTDEV"

	mount -o ro "$ROOTDEV" /root \
	|| die "$ROOTDEV: unable to mount"

	mount_by_uuid /boot /root/etc/fstab
	mount_by_uuid /boot/efi /root/etc/fstab
}

########################################
#
# Status checking - there are lots of things to chcek...
#
status_usage='
## status
Usage:
```
safeboot status [verbose]
```

Check the various configurations to see if the system is configured
with safeboot.  This is not exhaustive, but hopefully catches many
of the common things to setup.
'
usage+=$status_usage
commands+="|status"

status-secureboot()
{
	vendor_guid="8be4df61-93ca-11d2-aa0d-00e098032b8c"
	secureboot="$(efivar_read "SecureBoot-$vendor_guid" | bin2hex)"
	setupmode="$(efivar_read "SetupMode-$vendor_guid" | bin2hex)"

	if [ "$secureboot" != "01" ] || [ "$setupmode" != "00" ] ; then
		warn "UEFI SecureBoot not enabled! SecureBoot=$secureboot, SetupMode=$setupmode.  Fix in your BIOS setup menu"
		status=fail
	else
		debug "UEFI SecureBoot enabled"
	fi

	if [ ! -r "$PREFIX$DIR/cert.pem" ] \
	|| [ ! -r "$PREFIX$DIR/cert.pub" ] \
	|| [ ! -r "$PREFIX$DIR/cert.crt" ] \
	; then
		warn "Platform Key not present in $DIR. use 'safeboot key-init' or 'safeboot yubikey-init' to create"
		nokeys=1
		status=fail
	else
		debug "Platform Keys present"
	fi

	if ! efivar_read "PK-$vendor_guid" > "$TMP/pk.bin" ; then
		warn "EFI var PK not present"
	else
		tail -c +45 "$TMP/pk.bin" > "$TMP/pk.der" \
		|| warn "$TMP/pk.bin: not big enough?"

		if ! cmp --silent "$TMP/pk.der" "$PREFIX$DIR/cert.crt" ; then
			warn "EFI PK does not match $DIR/cert.crt"
			status=fail
		else
			debug "EFI PK maches $DIR/cert.crt"
		fi
	fi

	true
}

status-kernel()
{
	TARGET="$1"
	KERNEL="$PREFIX$EFIDIR/$TARGET/linux.efi"

	if [ ! -r "$KERNEL" ]; then
		warn "$KERNEL: kernel not present (use 'safeboot $TARGET-sign' to create"
		status=fail
		return 1
	else
		debug "$KERNEL: $TARGET kernel present"
	fi

	if ! sbverify \
		--cert "$PREFIX$CERT" \
		"$KERNEL" \
	> /dev/null 2>&1 ; then
		warn "$KERNEL: signature validation failed"
		status=fail
		return 1
	else
		debug "$KERNEL: signature validates"
	fi

	return 0
}

status-kernels()
{
	if ! efivar_read "$PCR_SIGNATURE" >/dev/null ; then
		warn "PCR signature is not present (use 'safeboot pcrs-sign' to setup)"
		status=fail
	else
		debug "PCR signature present"
	fi
	if ! tpm2 nvread "$TPM_NV_VERSION" >/dev/null ; then
		warn "TPM rollback counter not present (use 'safeboot pcrs-sign' to setup)"
		status=fail
	else
		debug "TPM rollback counter present"
	fi

	status-kernel "$RECOVERY_TARGET" || true
	status-kernel "$LINUX_TARGET" || true

	true
}

# Check the status of safeboot
status()
{
	show_help "$1" "$status_usage"

	if [ "$1" = "verbose" ]; then
		VERBOSE=1
	fi

	if [ ! -r "$PREFIX$DIR/safeboot.conf" ] ; then
		die "$PREFIX$DIR/safeboot.conf NOT installed?"
	fi
	if [ ! -r "$PREFIX$DIR/local.conf" ]; then
		die "$PREFIX$DIR/safeboot.conf NOT present?"
	fi

	if [ "$SIP" != "1" ]; then
		warn "SIP is not enabled (use 'safeboot sip-init' to setup)"
	else
		debug "SIP is enabled"
	fi

	status-secureboot -
	status-kernels -

	if [ "$status" = "fail" ] ; then
		warn "safeboot is not fully configured"
	else
		echo "safeboot is configured"
	fi
}

########################################

if [ $# -lt 1 ]; then
	die "Usage: $0 [$commands] ...."
fi

command=$1 ; shift
#echo "$commands"

case "$command" in
	-h|--help)
		echo "$usage"
		exit 0
		;;
	#$commands)
	yubikey-init|yubikey-pubkey|key-init|uefi-sign-keys|uefi-set-keys|luks-seal|pcrs-sign|sign-kernel|linux-sign|recovery-sign|reboot|recovery-reboot|remount|tpm2_trial_extend|sip-init|bootnext|unlock|mount-all|status)
		$command "$@"
		;;
	*)
		die "$0: subcommand $command unknown"
		;;
esac
